// class is an immutable field. nothing else is

/* add exception for very bad mismatched internal object */
class Object {
	private var fields: Vector<Object>;
	private def indices: HashMap<string, int> = Strings.newMap();
	var immutableFields = 0;

	var CLASS: int;

	new() {
		// obligated fields
		CLASS = addObligatedField("class");
	}

	private def addObligatedField(name: string) -> int {
		def idx = fields.length;
		fields.put(null);
		immutableFields++;
		indices.put(name, idx);
		return idx;
	}


	/* (method (get-field f) {
	 *    (try
	 *      (get-field-strict self f)
	 *    ;catch
	 *      E
         *      (set class self.class)
	 *      (while (!= class ()) {
	 *         ;search for method in class
         *         (for fn class.methods {
         *            (if (= fn.name f)
	 *               (return (bind fn self)))
	 *         })
	 *      })
	 *      
	 *    )
	 *    (raise ...)
	 * })
	 */

	// but if a field is not found, the behavior moves to class which
	// is the first field to look up methods
	def getField(name: string) -> Result {
		if (!indices.has(name)) {
			def idx = indices[name];
			def field = fields[idx];
			// XXX null check? pedantic but required if we allow del
			return Result.OK(field);
		}
		// field not found: go to class
		def cls = fields[CLASS];

	}
	def getFieldByIndex(idx: int) {
		return fields[idx];
	}

	/* Under the new object model, many methods are migrated to having
	 * Cicero-level definitions. This helps to clear up code clutter as we
	 * try to extract anything that's not pure Cicero.
	 *
	 * This adds potential for even more dynamicity (and the weirdness
	 * associated when you allow that). The problem is that it might be
	 * harder to optimize, but having all the code in Cicero means we
	 * could apply Cicero-level optimizations, if we implement that.
	 *
	 * The parts that require the runtime system, i.e. Virgil-level
	 * operations are abstracted into a "primitive" version of the method.
	 */

	/* (method (get-field f) {
	 *    (set name (f.display))
	 *    (self.prim-getfield name)
	 * })
	 */
	def o_getfield(name: Object) -> Result {
		def str = StrObject.!(name);
		return getField(str.str);
	}
	/* (method (display) {
	 *    (self.prim-display)
	 * })
	 */
	def o_display() -> Result {
		return StrObjects.fromString(Strings.format1("<obj 0x%x>", 
					Pointer.atObject(this) - Pointer.NULL));
	}
	/* (method (is-true) true) */
	def o_istrue() -> Result {
		return Result.OK(true);
	}
	/* (method (instance-of c) {
	 *    (set class (self.class))
	 *    (class.subclass c)
	 * })
	 */
	def o_instanceof(other: Object) -> Result {
		def cls = getFieldByIndex(CLASS);
	}

	def o_eq(other: Object) -> Result {
		return Result.OK(BoolObjects.fromBool(this == other));
	}
}

class FuncObject extends Object {
	def f_apply(args: Range<Object>) -> Result {
	}
}

def BASE: ClassObject;

/* Extending objects means that we can still use some Virgil-level space to
 * hold information related to the value (i.e. the actual string, int, bool).
 */
class ClassObject extends Object {
	new() {
		// obligated fields
		addObligatedField("name");       // string
		addObligatedField("superclass"); // class
		addObligatedField("init");       // code
		addObligatedField("fields");     // list
		addObligatedField("methods");    // map
	}
	def searchMethod(name: string) -> Result {
		var cls = this;
		while (cls != BASE) {
			
		}
	}
	/* (method (subclass other) {
	 *    (set cls self)
	 *    (while (!= cls ()) {
	 *       (if (= cls other)
	 *          (return true))
	 *       (set cls cls.superclass)
	 *    })
	 *    false
	 * })
	 */
	def c_display() -> Result;
	def c_subclass(other: Object) -> Result;
}

/* this could be a possible avenue for showcasing mutable classes, by switching
 * the class of a codeobject as the program tiers up
 */
class CodeObject extends Object {
	def co_display() -> Result;
}

class BoolObject extends Object {
	// no obligated fields
	// no cicero-defined methods! but does this make things unintuitive?
	// we have just one instance of true and false, but you are free to
	// manipulate them to make it terrible, so does it still make sense
	// for the method to return that?
}



/* Classes need to be constructed by three pieces of information
 * 1. obligatory fields (in `new`)
 * 2. primitive methods (defined in the class)
 * 3. Cicero-level methods (defined in an external file, but patched into
 *    the class definition by a script)
 */
/* NEW!: Obligatory fields are now special and whether or not they can be
 * written to is based on an compiler option.
 */

def newObject(args: Range<Object>) -> Result {
	if (args.length != 1)
		raise exception;
	def obj = args[0];
	if 
	// assert args.length == 1
	// obj = args[0]
	// assert obj.class <= class -- violates duck typing?
	// create the object
}

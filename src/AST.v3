/* An AST node is a underlying ASTData tagged with the source code location.
 */
class AST(data: ASTData, loc: FileRange) {}

/* Effective type of an AST node.
 *
 * When a field is of type Code, that indicates that its evaluation occurs in
 * a new frame, hence it should be parsed as a new Code object.
 */
type ASTData {
	case Lit(val: Object);
	/* The access mode is boxed for a convenience to the parser, but should
	 * be treated as immutable in the final AST.
	 */
	case VarGet(id: string, mode: Box<AccessMode>);
	case VarSet(id: string, mode: Box<AccessMode>, value: AST);
	case And(left: AST, right: AST);
	case Or(left: AST, right: AST);
	case Apply(tgt: AST, args: Array<AST>);
	case If(cond: AST, exprT: AST, exprF: AST);
	case Cond(cases: Array<(AST, AST)>);
	case Raise(exn: AST);
	case Catch(try: AST, exn: string, mode: Box<AccessMode>, catch: AST); // XXX mode required
	case Func(id: string, params: Array<string>, body: CodeObject, nonlocals: Vector<string>);
	case While(cond: AST, body: AST);
	case Begin(exprs: Array<AST>);
	case GetField(field: string, obj: AST);
	case SetField(field: string, obj: AST, val: AST);
	case Class(id: string, superclass: Maybe<AST>, init: Maybe<CodeObject>, fields: Array<(string, CodeObject)>, methods: Array<ASTData.Func>);
	case New(expr: AST);
	case List(elems: Array<AST>);
	case Return(value: AST);
}

/* Access mode for variable accesses.
 *
 * The access mode is boxed for convenience to the parser, but should
 * be treated as immutable in the final AST.
 */
type AccessMode {
	case Local;
	case Global;
	case Nonlocal;
}


enum Builtin(id: string, val: Value) {
	TRUE    ("true",     BoolValues.trueValue),
	FALSE   ("false",    BoolValues.falseValue),
	INT     ("int" ,     TypeValues.getTypeValue(Type.Int)),
	BOOL    ("bool",     TypeValues.getTypeValue(Type.Bool)),
	FUNC    ("func",     TypeValues.getTypeValue(Type.Func)),
	STR     ("str" ,     TypeValues.getTypeValue(Type.Str)),
	TYPE    ("type",     TypeValues.getTypeValue(Type.Type)),
	POOPCRAP("poopcrap", TypeValues.getTypeValue(Type.PoopCrap)),
	FRAME   ("frame",    TypeValues.getTypeValue(Type.Frame)),
	EXPR    ("expr",     TypeValues.getTypeValue(Type.Expr)),
	V_TYPEOF("typeof",   FuncValues.fromBuiltin(1, v_typeof)),
	V_PRINT ("print",    FuncValues.fromBuiltin(1, v_print)), 
	VV_EQ   ("=",        FuncValues.fromBuiltin(2, vv_eq)), 
	VV_NEQ  ("!=",       FuncValues.fromBuiltin(2, vv_neq)), 
	II_ADD  ("+",        FuncValues.fromBuiltin(2, ii_add)), 
	II_SUB  ("-",        FuncValues.fromBuiltin(2, ii_sub)), 
	II_MUL  ("*",        FuncValues.fromBuiltin(2, ii_mul)), 
	II_DIV  ("/",        FuncValues.fromBuiltin(2, ii_div)),
}

/* The type of all Builtin-Functions is
 *   Range<Value> -> (Value, bool)
 * return type:
 * - bool indicates whether function raised exception
 * - Value is either return value or exception
 */

def v_typeof(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 1) {
		exn = true;
		val = arityMismatch(1, vals);
	}

	if (!exn) {
		val = TypeValues.getTypeValue(vals[0].typeof());
	}

	return (val, exn);
}

def v_print(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 1) {
		exn = true;
		val = arityMismatch(1, vals);
	}

	if (!exn) {
		System.puts(vals[0].display());
		System.ln();
		val = PoopCrapValues.instance;
	}

	return (val, exn);
}

// FIXME string equality is wrong
def vv_eq(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}

	if (!exn) {
		val = if(vals[0] == vals[1], BoolValues.trueValue, BoolValues.falseValue);
	}

	return (val, exn);
}

// FIXME string equality is wrong
def vv_neq(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}

	if (!exn) {
		val = if(vals[0] != vals[1], BoolValues.trueValue, BoolValues.falseValue);
	}

	return (val, exn);
}

def ii_add(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}
	if (!exn && vals[0].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[0]);
	}
	if (!exn && vals[1].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[1]);
	}
	
	if (!exn) {
		val = IntValues.add(IntValue.!(vals[0]), IntValue.!(vals[1]));
	}

	return (val, exn);
}

def ii_sub(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}
	if (!exn && vals[0].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[0]);
	}
	if (!exn && vals[1].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[1]);
	}
	
	if (!exn) {
		val = IntValues.sub(IntValue.!(vals[0]), IntValue.!(vals[1]));
	}

	return (val, exn);
}

def ii_mul(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}
	if (!exn && vals[0].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[0]);
	}
	if (!exn && vals[1].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[1]);
	}
	
	if (!exn) {
		val = IntValues.mul(IntValue.!(vals[0]), IntValue.!(vals[1]));
	}

	return (val, exn);
}

def ii_div(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}
	if (!exn && vals[0].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[0]);
	}
	if (!exn && vals[1].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[1]);
	}
	if (!exn && (IntValue.!(vals[1])).val == 0) {
		exn = true;
		val = StrValues.getStrValue("arithmetic error: divide by zero");
	}
	
	if (!exn) {
		val = IntValues.div(IntValue.!(vals[0]), IntValue.!(vals[1]));
	}

	return (val, exn);
}

def typeMismatch(exp: Type, val: Value) -> Value {
	return StrValues.getStrValue(Strings.format2("type mismatch: expected %s, got %s", exp.display(), val.typeof().display()));
}

def arityMismatch(argc: int, vals: Range<Value>) -> Value {
	return StrValues.getStrValue(Strings.format2("arity mismatch: expected %d, got %d", argc, vals.length));
}

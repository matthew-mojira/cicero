enum Builtin(id: string, func: Range<Value> -> (Value, bool)) {
	V_TYPEOF("typeof", v_typeof),
	V_PRINT ("print",  v_print),
	VV_EQ   ("=",      vv_eq),
	VV_NEQ  ("!=",     vv_neq),
	II_ADD  ("+",      ii_add),
	II_SUB  ("-",      ii_sub),
	II_MUL  ("*",      ii_mul),
	II_DIV  ("/",      ii_div),
}

/* The type of all Builtin-Functions is
 *   Range<Value> -> (Value, bool)
 * return type:
 * - bool indicates whether function raised exception
 * - Value is either return value or exception
 */

def v_typeof(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 1) {
		exn = true;
		val = arityMismatch(1, vals);
	}

	if (!exn) {
		val = TypeValues.getTypeValue(vals[0].typeof());
	}

	return (val, exn);
}

def v_print(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 1) {
		exn = true;
		val = arityMismatch(1, vals);
	}

	if (!exn) {
		System.puts(vals[0].display());
		System.ln();
		val = PoopCrapValues.instance;
	}

	return (val, exn);
}

// FIXME string equality is wrong
def vv_eq(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}

	if (!exn) {
		val = if(vals[0] == vals[1], BoolValues.trueValue, BoolValues.falseValue);
	}

	return (val, exn);
}

// FIXME string equality is wrong
def vv_neq(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}

	if (!exn) {
		val = if(vals[0] != vals[1], BoolValues.trueValue, BoolValues.falseValue);
	}

	return (val, exn);
}

def ii_add(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}
	if (!exn && vals[0].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[0]);
	}
	if (!exn && vals[1].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[1]);
	}
	
	if (!exn) {
		val = IntValues.add(IntValue.!(vals[0]), IntValue.!(vals[1]));
	}

	return (val, exn);
}

def ii_sub(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}
	if (!exn && vals[0].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[0]);
	}
	if (!exn && vals[1].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[1]);
	}
	
	if (!exn) {
		val = IntValues.sub(IntValue.!(vals[0]), IntValue.!(vals[1]));
	}

	return (val, exn);
}

def ii_mul(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}
	if (!exn && vals[0].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[0]);
	}
	if (!exn && vals[1].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[1]);
	}
	
	if (!exn) {
		val = IntValues.mul(IntValue.!(vals[0]), IntValue.!(vals[1]));
	}

	return (val, exn);
}

def ii_div(vals: Range<Value>) -> (Value, bool) {
	var val: Value;
	var exn: bool;
	if (vals.length != 2) {
		exn = true;
		val = arityMismatch(2, vals);
	}
	if (!exn && vals[0].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[0]);
	}
	if (!exn && vals[1].typeof() != Type.Int) {
		exn = true;
		val = typeMismatch(Type.Int, vals[1]);
	}
	if (!exn && (IntValue.!(vals[1])).val == 0) {
		exn = true;
		val = StrValues.getStrValue("arithmetic error: divide by zero");
	}
	
	if (!exn) {
		val = IntValues.div(IntValue.!(vals[0]), IntValue.!(vals[1]));
	}

	return (val, exn);
}

def typeMismatch(exp: Type, val: Value) -> Value {
	return StrValues.getStrValue(Strings.format2("type mismatch: expected %s, got %s", exp.display(), val.typeof().display()));
}

def arityMismatch(argc: int, vals: Range<Value>) -> Value {
	return StrValues.getStrValue(Strings.format2("arity mismatch: expected %d, got %d", argc, vals.length));
}

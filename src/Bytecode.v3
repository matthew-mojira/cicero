layout Instruction {
	+0  opcode:  Opcode;
	+1  operand: u24; // you may treat this as unsigned or signed depending on opcode
	=4;
}

class Bytecode(instrs:     Array<byte>, 
		locals:     Array<string>,
		nonlocals:  Array<string>,
                stringPool: Array<string>,
                constPool:  Array<Object>,
                classPool:  Array<ClassObject -> ClassObject>,
                funcPool:   Array<ASTData.Func>,
                sourceMap:  Array<FileRange>)
{
	def var cache: Array<HashMap<ClassObject, int>>;

	new() {
		if (CiceroOptions.enableIC) {
			cache = Array.new(sourceMap.length);
			// Wow a lot of initialization
			for (i < cache.length) {
				cache[i] = HashMap.new(ClassObject.hash, ClassObject.==);
			}
		}
	}

	/* print this bytecode */
	def inspect() {
		def bc = instrs;
		var pc = 0;
		while (pc < bc.length) {
			def bc      = Ref<Instruction>.at(bc, pc);
			def opcode  = bc.opcode;
			def operand = bc.operand;
			def loc = sourceMap[pc >> 2];

			System.puts(Strings.format3("+%d: %s %d", pc, opcode.name, operand));
			if (loc != null)
				System.puts(Strings.format2(" (%d:%d)", loc.beginLine, loc.beginColumn));
			System.ln();
			
			pc += 4;
			// dispatch on bytecode
			match (opcode) {
				_ => ;
			}
		}
	}
}
 

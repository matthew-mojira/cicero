/* Code is an expression that can be evaluated.
 * 
 * It comes in three forms based on how that expression is defined.
 */
type Code {
	case Virgil(fn: Range<Object> -> Result);
	case AST(ast: AST);
	case Bytecode(bytecode: Bytecode);
}

/* Wraps around a pieces of Code. However, it also contains logic to compile
 * Code defined as an AST to bytecode. This means that it is internally
 * mutable (though the user cannot force the VM to compile AST to bytecode
 * right now).
 */
class CodeObject(range: FileRange) extends Object { // XXX range is null if code is virgil
	def var code: Code;

	/* Compile code */
	def compile(params: Array<string>) {
		match (code) {
			Virgil   => System.error("compile error", "attempting to compile Virgil code to bytecode");
			Bytecode => System.error("compile error", "compiling what has already been compiled to bytecode");
			AST(ast) => code = Code.Bytecode(BytecodeCompiler.new(ast, params).extract());
		}
	}

	def display() -> string { return "<code>"; }
	def isTrue()  -> bool   { return true; }

	/* METHODS */
	
	def co_display() -> Result {
		return Result.OK(StrObjects.fromString(display()));
	}
	def co_disassemble() -> Result {
		match (code) {
			Bytecode => return Result.OK(StrObjects.fromString(Code.Bytecode.!(code).bytecode.display()));
			_        => return Result.Exn(ExnObjects.fromVirgil("co.disassemble", "code object has not been compiled to bytecode"));
		}
	}
}

component CodeObjects {

	/* Create a CodeObject from a Virgil function */
	def fromVirgil(func: Range<Object> -> Result) -> CodeObject {
		def code = CodeObject.new(null); // XXX null
		code.code = Code.Virgil(func);
		return code;
	}

	/* Create a CodeObject from AST */
	def fromAST(ast: AST) -> CodeObject {
		// XXX should this be allowed?
		if (ast == null) return null;

		def code = CodeObject.new(ast.loc);
		code.code = Code.AST(ast);

		return code;
	}

	/* Pre-defined CodeObjects */

	/* Always throw exception. Used to prevent the user from instantiating
	 * built-in classes using `new`.
	 */
	def virgilFail: CodeObject = fromVirgil(doNotInstantiateThisClass);

	/* Always return () */
	def virgilPoopCrap: CodeObject = fromVirgil(justReturnPoopCrap);
}

def justReturnPoopCrap(range: Range<Object>) -> Result {
	if (range.length > 0) System.error("internal error", "poopcrap virgil > 0");
	return Result.OK(PoopCrapObjects.instance);
}

def doNotInstantiateThisClass(range: Range<Object>) -> Result {
	return Result.Exn(ExnObjects.fromVirgil("doNotInstantiateThisClass", Exceptions.doNotInstantiateThisClass));
}

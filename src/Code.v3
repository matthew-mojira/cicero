class Code(range: FileRange) {
	private new() {}
	
	def var virgil: Range<Object> -> (Object, bool);
	def var ast: AST;

	def var tier: i2;

	def var bytecode:   DataWriter     = DataWriter.new();
	def var strings:    Vector<string> = Vector.new();
	def var classholes: Vector<Class>  = Vector.new(); // XXX these are not real classes!
	def var constants:  Vector<Object> = Vector.new();

	/* Compile code (in {code}) to {this} as target */
	def compile(code: Code) {
		if (code.tier < 0) System.error("compile error", "attempting to compile Virgil code to bytecode");
		compileAST(code.ast);
		tier = 1;
	}

	def compileAST(ast: AST) {
		match (ast) {
			Lit(obj) => {
				def idx = constants.length;
				constants.put(obj);

				bytecode.putb(Opcode.LOAD_LIT.tag);
				bytecode.putb(idx);
			}
			Id(id) => {
				def idx = strings.length;
				strings.put(id);

				bytecode.putb(Opcode.LOAD_NAME.tag);
				bytecode.putb(idx);
			}
			Apply(tgt, args) => {
				compile(tgt);
				bytecode.putb(Opcode.ASSERT_FUNC.tag);
				bytecode.zeroN(1);
				for (arg in args) {
					compile(arg);
				}
				bytecode.putb(Opcode.CALL.tag);
				bytecode.putb(args.length);
			}
			If(cond, tru, fals) => {
				compile(cond);
				bytecode.putb(Opcode.JUMP_IF_FALSE.tag);
				def hole1 = bytecode.pos;
				bytecode.skipN(1); // hole to put jump offset
				compile(tru);
				bytecode.putb(Opcode.JUMP.tag);
				def hole2 = bytecode.pos;
				bytecode.skipN(1); // hole to put jump offset
				bytecode.data[hole1] = byte.view(bytecode.pos - hole1 - 1);
				compile(fals);
				bytecode.data[hole2] = byte.view(bytecode.pos - hole2 - 1);
			}
			Cond(cases) => {
				def ends: Vector<int> = Vector.new();
				for (c in cases) {
					def cond = c.0;
					def body = c.1;

					compile(cond);
					bytecode.putb(Opcode.JUMP_IF_FALSE.tag);
					def hole = bytecode.pos;
					bytecode.skipN(1); // hole to put jump offset
					compile(body);
					bytecode.putb(Opcode.JUMP.tag);
					ends.put(bytecode.pos);
					bytecode.skipN(1); // hole to put jump offset
					bytecode.data[hole] = byte.view(bytecode.pos - hole - 1);
				}
				def idx = constants.length;
				// XXX object creation in AST compilation!
				// could be problematic if we object lookup observable
				constants.put(StrObjects.getStrObject("cond error: no true breanch"));
				bytecode.putb(Opcode.LOAD_LIT.tag);
				bytecode.putb(idx);
				bytecode.putb(Opcode.RAISE.tag);
				bytecode.putb(0); // no operand
				// fill in all jump to end targets
				for (hole in ends.extract()) {
					bytecode.data[hole] = byte.view(bytecode.pos - hole - 1);
				}
			}
			Func(id, params, code) => {
				// XXX compiling code
				code.compile(code);
				
				def cst = constants.length;
				// XXX object creation in AST compilation!
				constants.put(FuncObjects.newFO(Func.new(id, params, code)));
			
				def str = strings.length;
				strings.put(id);

				bytecode.putb(Opcode.LOAD_LIT.tag);
				bytecode.putb(cst);
				bytecode.putb(Opcode.STORE_NAME.tag);
				bytecode.putb(str);
				bytecode.putb(Opcode.LOAD_NAME.tag);
				bytecode.putb(str);
			}
			Assign(id, code) => {
				def str = strings.length;
				strings.put(id);

				compile(code);
				bytecode.putb(Opcode.STORE_NAME.tag);
				bytecode.putb(str);
				bytecode.putb(Opcode.LOAD_NAME.tag);
				bytecode.putb(str);
			}
			Raise(exn) => {
				compile(exn);
				bytecode.putb(Opcode.RAISE.tag);
				bytecode.putb(0); // no operand
			}
			Catch(try, id, catch) => {
				bytecode.putb(Opcode.TRY.tag);
				def hole1 = bytecode.pos;
				bytecode.skipN(1);
				bytecode.putb(Opcode.CATCH.tag);
				bytecode.putb(0); // no operand
				bytecode.putb(Opcode.JUMP.tag);
				def hole2 = bytecode.pos;
				bytecode.skipN(1);
				bytecode.data[hole1] = byte.view(bytecode.pos - hole1 - 1);

				def idx = strings.length;
				strings.put(id);
				bytecode.putb(Opcode.STORE_NAME.tag);
				bytecode.putb(idx);

				compile(catch);
				bytecode.data[hole2] = byte.view(bytecode.pos - hole2 - 1);
			}
			Begin(exprs) => {
				for (i < exprs.length - 1) {
					compile(exprs[i]);
					bytecode.putb(Opcode.PULL.tag);
					bytecode.putb(200 + i);
				}
				compile(exprs[exprs.length - 1]);
			}
			While(cond, body) => {
				def pos = bytecode.pos;
				compile(cond);
				bytecode.putb(Opcode.JUMP_IF_FALSE_PEEK.tag);
				def hole = bytecode.pos;
				bytecode.skipN(1); // hole to put jump offset
				compile(body);
				bytecode.putb(Opcode.PULL.tag);
				bytecode.putb(100);
				bytecode.putb(Opcode.JUMP.tag);
				bytecode.skipN(1);
				bytecode.data[bytecode.pos - 1] = byte.view(pos - bytecode.pos);
				bytecode.data[hole] = byte.view(bytecode.pos - hole - 1);
			}
			GetField(id, obj) => {
				compile(obj);
				def idx = strings.length;
				strings.put(id);
				bytecode.putb(Opcode.GET_FIELD.tag);
				bytecode.putb(idx);
			}
			SetField(id, obj, val) => {
				compile(obj);
				compile(val);
				def idx = strings.length;
				strings.put(id);
				bytecode.putb(Opcode.SET_FIELD.tag);
				bytecode.putb(idx);
			}
			Class(id, superclass, init, fields, methods) => {
				// there are subcodes which are getting compiled here
				// TODO should this compilation process just be part of code creation?
				match (superclass) {
					Nothing => {
						def idx = constants.length;
						constants.put(ClassObject.new(Objects.classBase));
						bytecode.putb(Opcode.LOAD_LIT.tag);
						bytecode.putb(idx);
					}
					Just(expr) => compile(expr);
				}
				var init2: Code;
				match (init) {
					Nothing => ;
					Just(code) => {
						code.compile(code);
						init2 = code;
					}
				}
				def idx = classholes.length;
				//                            XXX
				classholes.put(Class.new(id, null, init2, fields, Arrays.map(methods, funcToFunc)));
				bytecode.putb(Opcode.CREATE_CLASS.tag);
				bytecode.putb(idx);
				def str = strings.length;
				strings.put(id);
				bytecode.putb(Opcode.STORE_NAME.tag);
				bytecode.putb(str);
				bytecode.putb(Opcode.LOAD_NAME.tag);
				bytecode.putb(str);
			}
			New(obj) => {
				compile(obj);
				bytecode.putb(Opcode.NEW.tag);
				bytecode.putb(0); // no operand
			}

//			_ => System.error("compile error", "unsupported AST node");
		}
		
	}
}

component Codes {
	def fromVirgil(fn: Range<Object> -> (Object, bool)) -> Code {
		def code = Code.new(null);
		code.virgil = fn;
		code.tier = -1;
		return code;
	}
	def fromAST(ast: AST, range: FileRange) -> Code {
		def code = Code.new(range);
		code.ast = ast;
		code.tier = 0;

		return code;
	}
	def virgilFail: Code = fromVirgil(doNotInstantiateThisClass);
	def virgilPoopCrap: Code = fromVirgil(justReturnPoopCrap);
}

def doNotInstantiateThisClass(range: Range<Object>) -> (Object, bool) {
	return (StrObjects.getStrObject("do not use `new` to instantiate this class"), true);
}

def justReturnPoopCrap(range: Range<Object>) -> (Object, bool) {
	if (range.length > 0) System.error("internal error", "poopcrap virgil > 0");
	return (PoopCrapObjects.instance, false);
}

def funcToFunc(f: AST.Func) -> Func {
	def code = f.body;
	code.compile(code);
	return Func.new(f.id, f.params, code);	
}

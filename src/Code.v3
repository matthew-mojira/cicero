type Code {
	case Virgil(fn: Range<Object> -> Result);
	case AST(ast: AST);
	case Bytecode(bytecode: Bytecode);
	case Wasm(wasm: WasmFunction); // defined at bottom of file
}

class CodeObject(range: FileRange) extends Object { // XXX range is null if code is virgil
	def var code: Code;

	/* Compile code */
	def compile(params: Array<string>) {
		match (code) {
			Virgil   => System.error("compile error", "attempting to compile Virgil code to bytecode");
			Bytecode => System.error("compile error", "compiling what has already been compiled to bytecode");
			Wasm     => System.error("compile error", "compiling what has already been compiled to wasm");
			AST(ast) => match (CiceroOptions.evalTier) {
				1 => code = Code.Bytecode(BytecodeCompiler.new(ast, params).extract());
				2 => code = Code.Wasm(WasmCompiler.new(ast, params).compile());
				_ => System.error("compile error", "attempting to compile on interpreter tier");
			}
		}
	}

	def display() -> string { return "<code>"; }
	def isTrue()  -> bool   { return true; }
	
	def co_display() -> Result {
		return Result.OK(StrObjects.fromString(display()));
	}
	def co_disassemble() -> Result {
		match (code) {
			Bytecode => return Result.OK(StrObjects.fromString(Code.Bytecode.!(code).bytecode.display()));
			_        => return Result.Exn(ExnObjects.fromVirgil("co.disassemble", "code object has not been compiled to bytecode"));
		}
	}
}

component CodeObjects {

	def fromVirgil(func: Range<Object> -> Result) -> CodeObject {
		def code = CodeObject.new(null); // XXX null
		code.code = Code.Virgil(func);
		return code;
	}

	def fromAST(ast: AST) -> CodeObject {
		// XXX should this be allowed?
		if (ast == null) return null;

		def code = CodeObject.new(ast.loc);
		code.code = Code.AST(ast);

		return code;
	}

	def virgilFail: CodeObject = fromVirgil(doNotInstantiateThisClass);
	def virgilPoopCrap: CodeObject = fromVirgil(justReturnPoopCrap);
}

def justReturnPoopCrap(range: Range<Object>) -> Result {
	if (range.length > 0) System.error("internal error", "poopcrap virgil > 0");
	return Result.OK(PoopCrapObjects.instance);
}

def doNotInstantiateThisClass(range: Range<Object>) -> Result {
	return Result.Exn(ExnObjects.fromVirgil("doNotInstantiateThisClass", Exceptions.doNotInstantiateThisClass));
}

// sorted by arity
type WasmFunction {
	case Func0(fn: FrameObject -> Object);
	case Func1(fn: (FrameObject, Object) -> Object);
	case Func2(fn: (FrameObject, Object, Object) -> Object);
	case Func3(fn: (FrameObject, Object, Object, Object) -> Object);
	case Func4(fn: (FrameObject, Object, Object, Object, Object) -> Object);
	case Func5(fn: (FrameObject, Object, Object, Object, Object, Object) -> Object);
	case Func6(fn: (FrameObject, Object, Object, Object, Object, Object, Object) -> Object);
	case Func7(fn: (FrameObject, Object, Object, Object, Object, Object, Object, Object) -> Object);
	case Func8(fn: (FrameObject, Object, Object, Object, Object, Object, Object, Object, Object) -> Object);
	case Func9(fn: (FrameObject, Object, Object, Object, Object, Object, Object, Object, Object, Object) -> Object);
}

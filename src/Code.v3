/* Code is an expression that can be evaluated.
 * 
 * It comes in three forms based on how that expression is defined.
 */
type Code {
	case Virgil(fn: Range<Object> -> Result);
	case AST(ast: AST);
	case Bytecode(bytecode: Bytecode);
	case Wasm(wasm: WasmFunction); // defined at bottom of file
}

/* Wraps around a pieces of Code. However, it also contains logic to compile
 * Code defined as an AST to bytecode. This means that it is internally
 * mutable (though the user cannot force the VM to compile AST to bytecode
 * right now).
 */
class CodeObject(range: FileRange) extends Object { // XXX range is null if code is virgil
	def var code: Code;

	/* Compile code */
	def compile(params: Array<string>) {
		match (code) {
			Virgil   => System.error("compile error", "attempting to compile Virgil code to bytecode");
			Bytecode => System.error("compile error", "compiling what has already been compiled to bytecode");
			Wasm     => System.error("compile error", "compiling what has already been compiled to wasm");
			AST(ast) => match (CLOptions.TIER.get()) {
				1 => code = Code.Bytecode(BytecodeCompiler.new(ast, params).extract());
				2 => code = Code.Wasm(WasmCompiler.new(ast, params).compile());
				_ => System.error("compile error", "attempting to compile on interpreter tier");
			}
		}
	}

	def display() -> string { return "<code>"; }
	def isTrue()  -> bool   { return true; }

	/* METHODS */
	
	def co_display() -> Result {
		return Result.OK(StrObjects.fromString(display()));
	}
	def co_disassemble() -> Result {
		match (code) {
			Bytecode => return Result.OK(StrObjects.fromString(Code.Bytecode.!(code).bytecode.display()));
			_        => return Result.Exn(ExnObjects.fromVirgil("co.disassemble", "code object has not been compiled to bytecode"));
		}
	}
}

component CodeObjects {

	/* Create a CodeObject from a Virgil function */
	def fromVirgil(func: Range<Object> -> Result) -> CodeObject {
		def code = CodeObject.new(null); // XXX null
		code.code = Code.Virgil(func);
		return code;
	}

	/* Create a CodeObject from AST */
	def fromAST(ast: AST) -> CodeObject {
		// XXX should this be allowed?
		if (ast == null) return null;

		def code = CodeObject.new(ast.loc);
		code.code = Code.AST(ast);

		return code;
	}

	/* Pre-defined CodeObjects */

	/* Always throw exception. Used to prevent the user from instantiating
	 * built-in classes using `new`.
	 */
	def virgilFail: CodeObject = fromVirgil(doNotInstantiateThisClass);

	/* Always return () */
	def virgilPoopCrap: CodeObject = fromVirgil(justReturnPoopCrap);
}

def justReturnPoopCrap(range: Range<Object>) -> Result {
	if (range.length > 0) System.error("internal error", "poopcrap virgil > 0");
	return Result.OK(PoopCrapObjects.instance);
}

def doNotInstantiateThisClass(range: Range<Object>) -> Result {
	return Result.Exn(ExnObjects.fromVirgil("doNotInstantiateThisClass", Exceptions.doNotInstantiateThisClass));
}

// sorted by arity
type WasmFunction {
	case Func0(fn: FrameObject -> Box<Result>);
	case Func1(fn: (FrameObject, Object) -> Box<Result>);
	case Func2(fn: (FrameObject, Object, Object) -> Box<Result>);
	case Func3(fn: (FrameObject, Object, Object, Object) -> Box<Result>);
	case Func4(fn: (FrameObject, Object, Object, Object, Object) -> Box<Result>);
	case Func5(fn: (FrameObject, Object, Object, Object, Object, Object) -> Box<Result>);
	case Func6(fn: (FrameObject, Object, Object, Object, Object, Object, Object) -> Box<Result>);
	case Func7(fn: (FrameObject, Object, Object, Object, Object, Object, Object, Object) -> Box<Result>);
	case Func8(fn: (FrameObject, Object, Object, Object, Object, Object, Object, Object, Object) -> Box<Result>);
	case Func9(fn: (FrameObject, Object, Object, Object, Object, Object, Object, Object, Object, Object) -> Box<Result>);
}

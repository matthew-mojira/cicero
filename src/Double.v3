def FLOAT_MAX_LENGTH: int = 14;
class DoubleObject(val: double) extends Object {
	// @todo: need to work on display for doubles without need to roundd to floats;
	// but this would be smthg to work on the virgil side
	def display() -> string{
		var a: Array<byte> = Array<byte>.new(FLOAT_MAX_LENGTH);
		var l = Floats.renderFloat(float.roundd(val), a, 0);
		return Strings.format1("%s", Arrays.range(a, 0, l));
	}

	def isTrue()  => true;

    def do_display() => Result.OK(StrObjects.fromString(display()));

	/* arithmetic */

	def do_sqrt() -> Result {
		return Result.OK(DoubleObjects.fromDouble(double.sqrt(this.val)));
	}

	def do_neg() => Result.OK(DoubleObject.new(- val));
	def do_add(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return DoubleIntOperations.addIntDouble(iobj, this);
		}
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dval = (DoubleObject.!(obj).val);
			return Result.OK(DoubleObjects.fromDouble(val + dval));
		}
		return Result.Exn(ExnObjects.fromVirgil("+", "Can only perform '+' on a `double` with another `double` or `int`"));
	}

	def do_sub(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return DoubleIntOperations.subDoubleInt(this, iobj);
		}
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dval = (DoubleObject.!(obj).val);
			return Result.OK(DoubleObjects.fromDouble(val - dval));
		}
		return Result.Exn(ExnObjects.fromVirgil("-", "Can only perform '-' on a `double` with another `double` or `int`"));
	}

	def do_mul(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return DoubleIntOperations.mulIntDouble(iobj, this);
		}
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dval = (DoubleObject.!(obj).val);
			return Result.OK(DoubleObjects.fromDouble(val * dval));
		}
		return Result.Exn(ExnObjects.fromVirgil("*", "Can only perform '*' on a `double` with another `double` or `int`"));
	}

	def do_div(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return DoubleIntOperations.divDoubleInt(this, iobj);
		}
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dval = (DoubleObject.!(obj).val);
			if (dval == 0) return Result.Exn(ExnObjects.fromVirgil("double.div", divideByZero));
			return Result.OK(DoubleObjects.fromDouble(val / dval));
		}
		return Result.Exn(ExnObjects.fromVirgil("/", "Can only perform '/' on a `double` with another `double` or `int`"));
	}

	/* Comparisons */

	def do_eq(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dval = (DoubleObject.!(obj).val);
			return Result.OK(BoolObjects.fromBool(val == dval));
		}
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return DoubleIntOperations.eqIntDouble(iobj, this);
		}
		return Result.OK(BoolObjects.fromBool(false));
	}

	def do_lt(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dval = (DoubleObject.!(obj).val);
			return Result.OK(BoolObjects.fromBool(val < dval));
		}
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return DoubleIntOperations.ltDoubleInt(this, iobj);
		}
		return Result.Exn(ExnObjects.fromVirgil("<", "Can only perform '<' on a `double` with another `double` or `int`"));
	}

	def do_gt(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dval = (DoubleObject.!(obj).val);
			return Result.OK(BoolObjects.fromBool(val > dval));
		}
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return DoubleIntOperations.gtDoubleInt(this, iobj);
		}
		return Result.Exn(ExnObjects.fromVirgil(">", "Can only perform '>' on a `double` with another `double` or `int`"));
	}

	def do_geq(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dval = (DoubleObject.!(obj).val);
			return Result.OK(BoolObjects.fromBool(val >= dval));
		}
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return DoubleIntOperations.geqDoubleInt(this, iobj);
		}
		return Result.Exn(ExnObjects.fromVirgil(">=", "Can only perform '>=' on a `double` with another `double` or `int`"));
	}

	def do_leq(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dval = (DoubleObject.!(obj).val);
			return Result.OK(BoolObjects.fromBool(val <= dval));
		}
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return DoubleIntOperations.leqDoubleInt(this, iobj);
		}
		return Result.Exn(ExnObjects.fromVirgil("<=", "Can only perform '<=' on a `double` with another `double` or `int`"));
	}
}

component DoubleObjects {
	def fromDouble(val: double) => DoubleObject.new(val);
}

// For parsing purposes
// Source: From virgil's f64 implementation
component DoubleParserHelper{
	def f64(sign: int, exp: int, mantissa: u64) -> double {
		var bits = if(sign != 0, 0x8000000000000000ul);
		if (exp < -1076) return double.view(bits);
		if (exp <= -1023) {
			// subnormal; make implicit 1 explicit and shift right
			mantissa = 0x8000000000000000ul | mantissa >> 1;
			var shift = -1023 - exp;
			mantissa = (u64.view(roundOff(mantissa, 12 + shift)) << 12) + (mantissa >> u6.view(shift));
			exp = -1023;
		} else if (exp >= 1024) {
			// saturate large exponents to infinity
			return if (sign != 0, double.view(0xfff0000000000000ul),double.view(0x7ff0000000000000ul));
		}
		bits |= (u64.view(u11.view(exp + 1023)) << 52);
		bits |= mantissa >> 12;
		return double.view(bits);
	}
}

def roundOff(val: u64, bits: int) -> u1 {
	var b = val << u6.view(64 - bits);
	var max = 0x8000000000000000uL;
	if (b < max) return 0;
	if (b > max) return 1;
	if ((val << u6.view(63 - bits)) >= max) return 1;
	return 0;
}
def divideByZero = "division by zero";
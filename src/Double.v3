def FLOAT_MAX_LENGTH: int = 14;
class DoubleObject(val: double) extends Object {
	// @todo: need to work on display for doubles;
	// but this would be smthg to work on the virgil side
	def display() -> string{
		var a: Array<byte> = Array<byte>.new(FLOAT_MAX_LENGTH);
		var l = Floats.renderFloat(float.roundd(val), a, 0);
		return Strings.format1("%s", Arrays.range(a, 0, l));
	}

	def isTrue()  => true;

    def do_display() => Result.OK(StrObjects.fromString(display()));
}

component DoubleObjects {
	def fromDouble(val: double) => DoubleObject.new(val);
}

// For parsing purposes
// Source: From virgil's f64 implementation
component DoubleParserHelper{
	def f64(sign: int, exp: int, mantissa: u64) -> double {
		var bits = if(sign != 0, 0x8000000000000000ul);
		if (exp < -1076) return double.view(bits);
		if (exp <= -1023) {
			// subnormal; make implicit 1 explicit and shift right
			mantissa = 0x8000000000000000ul | mantissa >> 1;
			var shift = -1023 - exp;
			mantissa = (u64.view(roundOff(mantissa, 12 + shift)) << 12) + (mantissa >> u6.view(shift));
			exp = -1023;
		} else if (exp >= 1024) {
			// saturate large exponents to infinity
			return if (sign != 0, double.view(0xfff0000000000000ul),double.view(0x7ff0000000000000ul));
		}
		bits |= (u64.view(u11.view(exp + 1023)) << 52);
		bits |= mantissa >> 12;
		return double.view(bits);
	}
}

def roundOff(val: u64, bits: int) -> u1 {
	var b = val << u6.view(64 - bits);
	var max = 0x8000000000000000uL;
	if (b < max) return 0;
	if (b > max) return 1;
	if ((val << u6.view(63 - bits)) >= max) return 1;
	return 0;
}
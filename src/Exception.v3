/* Represents a Cicero language exception. */
class ExnObject extends Object {
	def isTrue()  -> bool   { return true; }

	def message: string;
	// XXX: Exception locations in Virgil code have a null FileRange.
	def stacktrace: Vector<(string, FileRange)> = Vector.new();
	
	private new(message, fn: string, loc: FileRange) {
		stacktrace.put((fn, loc));
	}

	def display() -> string {
		return Strings.format1("<exception '%s'>", message);
	}

	def print() {
		def str = StringBuilder.new();
		str.puts(Strings.format1("exception: %s\n", message));
		for (i < stacktrace.length) {
			def range = stacktrace[i].1;
			def fn = stacktrace[i].0;
			str.puts(formatLine(fn, range));
			str.ln();
		}
		System.puts(str.extract());
	}
	
	/* METHODS */
	
	def e_display() -> Result {
		return Result.OK(StrObjects.fromString(display()));
	}

	/* Stacktrace prepares a list of strings where each string is one
	 * frame in the stacktrace, which is not really useful.
	 */
	def e_stacktrace() -> Result {
		return Result.OK(ListObjects.fromArray(stacktrace.send(Ranges.map(_, compose(formatLine, StrObjects.fromString, Object.!<StrObject>)))));
	}
}

component ExnObjects {
	/* Create an exception object for something that happened in Wasm
	 * (i.e. null location and function)
	 */
	def fromWasm(msg: string) -> ExnObject {
		return ExnObject.new(msg, null, null); // TODO we should get more exception information here
	}
	/* Create an exception object for something that happened in Virgil
	 * (i.e. null location)
	 */
	def fromVirgil(fn: string, msg: string) -> ExnObject {
		return ExnObject.new(msg, fn, null);
	}
	/* Create an exception from a string and location */
	def fromStrObject(str: StrObject, fn: string, loc: FileRange) -> ExnObject {
		def obj = ExnObject.new(str.str, fn, loc);
		return obj;
	}
}

/* Format a line of the exception in the stacktrace printout. */
def formatLine(fn: string, range: FileRange) -> string {
	if (fn == null) return "  at <wasm func>";
	def str = StringBuilder.new();
	str.put1("  at %s (", fn);
	if (range == null) {
		str.puts("<Virgil code>");
	} else {
		str.put3("%s:%d:%d", range.fileName, range.beginLine, range.beginColumn);
	}
	str.puts(")");
	return str.extract();
}

def compose<A, B, C, D>(f: A -> B, g: B -> C, h: C -> D) -> (A -> D) {
	return fun (x: A) => h(g(f(x)));
}

class Expr(data: ExprData, range: FileRange) {
}

type ExprData {
	case Lit(val: Value);
	case Id(id: string);
	case Apply(tgt: Expr, args: Array<Expr>);
}

component Exprs {
	def parse_sexps(sexps: Array<Sexp>) -> Array<Expr> {
		return Arrays.map(sexps, parse_sexp);
	}
}


def parse_sexp(sexp: Sexp) -> Expr {
	match (sexp.data) {
		Token(str) => {
			match (parseLit(str)) {
				Just(lit) => return Expr.new(ExprData.Lit(lit), sexp.range);
				Nothing => {
					// must be an identifier
					if (!isValidIdentifier(str))
						System.error("parse error", Strings.format1("invalid identifier \"%s\"", str));
					return Expr.new(ExprData.Id(str), sexp.range);
				}
			}
		}
		Apply(sexps) => {
			if (sexps.length == 0) {
				return Expr.new(ExprData.Lit(Value.PoopCrap), sexp.range);
			}
			def head = parse_sexp(sexps[0]);
			def tail = Ranges.map(sexps[1 ...], parse_sexp);

			return Expr.new(ExprData.Apply(head, tail), sexp.range);
		}
	}
}

def parseLit(str: string) -> Maybe<Value> {
	// assume string nonempty
	if (str == "true")  return Maybe.Just(Value.Bool(true));
	if (str == "false") return Maybe.Just(Value.Bool(false));

	if (str == "int")  return Maybe.Just(Value.Type(Type.Int));
	if (str == "bool") return Maybe.Just(Value.Type(Type.Bool));
	if (str == "func") return Maybe.Just(Value.Type(Type.Func));
	if (str == "str")  return Maybe.Just(Value.Type(Type.Str));
	if (str == "char") return Maybe.Just(Value.Type(Type.Char));
	if (str == "type") return Maybe.Just(Value.Type(Type.Type));
	if (str == "poopcrap") return Maybe.Just(Value.Type(Type.PoopCrap));

	if (str[0] == '\"') return Maybe.Just(Value.Str(Ranges.dup(str[1 ... str.length - 1])));

	// only parse for decimals at the moment
	def res = Ints.parseDecimal(str, 0);
	def status = res.0, value = res.1;
	if (status <= 0) return Maybe.Nothing;
	if (status != str.length) {
		System.puts(Strings.format3("string is \"%s\", found %d characters and length is %d\n",
					str, status, str.length));
		System.error("parse error", "trailing information after integer literal");
	}
	// any characters that start an integer literal cannot be part of a valid identifier
	return Maybe.Just(Value.Int(value));
}

// rules for identifiers
// [A-Za-z][A-Za-z0-9\-_]*
def isValidIdentifier(str: string) -> bool {
	if (str.length == 0) return false;
	var i = 0;

	if (!isAlpha(str[i])) return false;
	for (i = 1; i < str.length; i++) {
		def char = str[i];
		if (!(isAlpha(char) || (char >= '0' && char <= '9') || char == '_' || char == '-'))
			return false;
	}
	return true;
}

def isAlpha(char: byte) -> bool {
	return (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z');
}

// f1 must come before f2
def addRange(f1: FileRange, f2: FileRange) -> FileRange {
	if (f1.fileName != f2.fileName) System.error("file range error", "conflicting filenames when adding file ranges");
	return FileRange.new(f1.fileName, f1.beginLine, f1.beginColumn, f2.endLine, f2.endColumn);
}

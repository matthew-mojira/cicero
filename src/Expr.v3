class Expr(data: ExprData, range: FileRange) {
	def display() -> string {
		return data.display();
	}
}

type ExprData {
	case Lit(val: Value) {
		def display() -> string {
			return val.display();
		}
	}
	case Id(id: string) {
		def display() -> string {
			return id;
		}
	}
	case Apply(tgt: Expr, args: Array<Expr>) {
		def display() -> string {
			var buf = StringBuilder.new();
			buf.puts("(APPLY ");
			buf.puts(tgt.display());
			for (arg in args) {
				buf.putc(' ');
				buf.puts(arg.display());
			}
			buf.putc(')');
			return buf.extract();
		}
	}
	case If(cond: Expr, exprT: Expr, exprF: Expr) {
		def display() -> string {
			return Strings.format3("(IF %s %s %s)", cond.display(), exprT.display(), exprF.display());
		}
	}
	case Raise(exn: Expr) {
		def display() -> string {
			return Strings.format1("(RAISE %s)", exn.display());
		}
	}
	// TODO you raise a value as an exception, but when you catch the exception
	// you cannot catch the value
	case Catch(try: Expr, catch: Expr) {
		def display() -> string {
			return Strings.format2("(TRY-CATCH %s %s)", try.display(), catch.display());
		}
	}
	// this is a function expression (which evaluates to function value)
	case Func(id: string, params: Array<string>, body: Expr) {
		def display() -> string {
			def buf = StringBuilder.new();
			buf.puts("(FUNC (");
			buf.puts(id);
			buf.puts(" (");
			for (param in params) {
				buf.puts(param);
				buf.putc(' '); // FIXME trailing space
			}
			buf.puts(") ");
			buf.puts(body.display());
			buf.putc(')');
			return buf.extract();
		}
	}
	def display() -> string;
}

// f1 must come before f2
def addRange(f1: FileRange, f2: FileRange) -> FileRange {
	if (f1.fileName != f2.fileName) System.error("file range error", "conflicting filenames when adding file ranges");
	return FileRange.new(f1.fileName, f1.beginLine, f1.beginColumn, f2.endLine, f2.endColumn);
}

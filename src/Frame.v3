/* FrameObject refers to the `frame` type in Cicero, but in Virgil this is
 * an abstract class extended by Virgil/AST/Bytecode frames internally.
 */
class FrameObject(prev: FrameObject, code: CodeObject, args: Array<(string, Object)>) extends Object {
	var globals: HashMap<string, Object>;

	private new() {
		if (prev == null) {
			globals = Strings.newMap();
		} else {
			globals = prev.globals;
		}
	}

	// status flags as the result of evaluation
	var result: Result;

	// retrieving results, but check first!
	def getValue() -> Object {
		return Result.OK.!(result).value;
	}

	def getExn() -> ExnObject {
		return Result.Exn.!(result).exn;
	}

	/* Current location of the evaluation. This doesn't need to be exact, but it
	 * should be correct whenever an exception is raised so that the stacktrace
	 * is accurate.
	 */
	var loc: FileRange;

	/* How to evaluate this frame. It must set {result} based on what happens. */
	def eval();
	// XXX this is for top-level code. note that this may have a discrepancy in tiers!
	def evalCode(code: CodeObject) -> Object;

	def newFrame(code: CodeObject, args: Array<(string, Object)>) -> FrameObject {
		return FrameObjects.newFrame(this, code, args);
	}

	// throw sets the exception value in the frame right away
	def throw(msg: string) {
		result = Result.Exn(ExnObject.new(msg, loc));
	}
	def throw1<T>(msg: string, t1: T) {
		result = Result.Exn(ExnObject.new(Strings.format1(msg, t1), loc));
	}

	def rethrow(exn: ExnObject) {
		exn.stacktrace.put(loc);
		result = Result.Exn(exn);
	}

	def isExn() -> bool {
		return Result.Exn.?(result);
	}

	def resetExn() {
		result = Result.Uncomputed;
	}

	def assertType(exp: ClassObject, val: Object) {
		if (!val.instanceOf(exp))
			throw(Strings.format2("type mismatch: expected %s, got %s", exp.display(), val.getClass().display()));
	}

	def assertArity<T>(argc: int, vals: Range<T>) {
		if (vals.length != argc)
			throw(Strings.format2("arity mismatch: expected %d, got %d", argc, vals.length));
	}
}

// FIXME find a better way to pass arguments between different tiers. More importantly,
// we have to figure out indexes for locals instead of looking them up by name.
component FrameObjects {
	def newFrame(prev: FrameObject, code: CodeObject, args: Array<(string, Object)>) -> FrameObject {
		match (code.tier) {
			-1 => return VirgilFrame.new(prev, code, args);
			 0 => return ASTFrame.new(prev, code, args);
			 1 => return BytecodeFrame.new(prev, code, args);
		} else {
			System.error("eval error", Strings.format1("unrecognized tier: %d", code.tier));
		}
		return null;
	}
	def newTopFrame() -> FrameObject {
		var frame: FrameObject;
		if (Tiers.enableTier1) {
			frame = BytecodeFrame.new(null, null, null);
		} else {
			frame = ASTFrame.new(null, null, null);
		}
		for (builtin in Builtin.set.all) {
			frame.globals[builtin.id] = builtin.val;
		}
		return frame;
	}
}

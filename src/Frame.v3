/* FrameObject refers to the `frame` type in Cicero, but in Virgil this is
 * an abstract class extended by Virgil/AST/Bytecode frames internally.
 */
class FrameObject(prev: FrameObject, code: CodeObject, args: Array<(string, Object)>) extends Object {
	var globals: HashMap<string, Object>;

	private new() {

		if (prev == null) {
			globals = Strings.newMap();
		} else {
			globals = prev.globals;
		}
	}

	// status flags as the result of evaluation
	var exn: bool = false;  // whether evaluation threw uncaught exception
	var val: Object;        // result of evaluation or exception value

	/* Current location of the evaluation. This doesn't need to be exact, but it
	 * should be correct whenever an exception is raised so that the stacktrace
	 * is accurate.
	 */
	var loc: FileRange;
	def stacktrace = Vector<FileRange>.new();

	/* How to evaluate this frame. It must set {exn} and {val} based on what
	 * happens.
    */
	def eval();
	// XXX this is for top-level code. note that this may have a discrepancy
	// in tiers!
	def evalCode(code: CodeObject) -> Object;

	def newFrame(code: CodeObject, args: Array<(string, Object)>) -> FrameObject {
		return FrameObjects.newFrame(this, code, args);
	}

	// throw sets the exception value in the frame right away
	def throw(value: Object) {
		stacktrace.put(loc); // FIXME figure out proper error reporting for tier1
		exn = true;
		val = value;
	}

	def assertType(exp: ClassObject, val: Object) {
		if (!val.instanceOf(exp))
			throw(StrObjects.getStrObject(Strings.format2("type mismatch: expected %s, got %s", exp.display(), val.getClass().display())));
	}

	def assertArity<T>(argc: int, vals: Range<T>) {
		if (vals.length != argc)
			throw(StrObjects.getStrObject(Strings.format2("arity mismatch: expected %d, got %d", argc, vals.length)));
	}
}

// FIXME find a better way to pass arguments between different tiers. More importantly,
// we have to figure out indexes for locals instead of looking them up by name.
component FrameObjects {
	def newFrame(prev: FrameObject, code: CodeObject, args: Array<(string, Object)>) -> FrameObject {
		match (code.tier) {
			-1 => return VirgilFrame.new(prev, code, args);
			 0 => return ASTFrame.new(prev, code, args);
			 1 => return BytecodeFrame.new(prev, code, args);
		} else {
			System.error("eval error", Strings.format1("unrecognized tier: %d", code.tier));
		}
		return null;
	}
	def newTopFrame() -> FrameObject {
		var frame: FrameObject;
		if (Tiers.enableTier1) {
			frame = BytecodeFrame.new(null, null, null);
		} else {
			frame = ASTFrame.new(null, null, null);
		}
		for (builtin in Builtin.set.all) {
			frame.globals[builtin.id] = builtin.val;
		}
		return frame;
	}
}

class Frame(prev: Frame, 
		locals: HashMap<string, Object>, //  \
		args: Array<Object>,             //  / XXX combine these together
		code: Code) {
	var globals: HashMap<string, Object>;

	// status flags as the result of evaluation
	var exn: bool = false;  // whether evaluation threw uncaught exception
	var stacktrace = Vector<FileRange>.new();
	var val: Object;        // result of evaluation or exception value

	/* Initializing the frame also evaluates it (except for top-level frames). */
	new() {
		if (prev == null) {
			// this is the top-level frame, where locals = globals
			globals = locals;
		} else {
			globals = prev.globals;

			// evaluate the frame
			eval(code);
		}
	}

	/* You should inspect the frame to determine if the value is meaningful. If
	 * there is no exception in the frame, then you can accept the value.
	 * Otherwise, ignore the return value. It is usually, but not guaranteed, to
	 * be null.
	 */
	def eval(code: Code) -> Object {
		// dispatch on the code tier
		def evalFuncs = [virgilEval, tier0Eval, tier1Eval];
		def v = evalFuncs[code.tier + 1](code);
		if (!exn)
			val = v;
		return v;
	}

	private def virgilEval(code: Code) -> Object {
		def ret = code.virgil(args);
		val = ret.0;
		exn = ret.1;
		if (exn) stacktrace.put(null); // XXX null signifies native code
		return val;
	}

	var curr: Code;

	private def tier0Eval(code: Code) -> Object {
		curr = code;
		var value: Object;

		System.puts(code.ast.whichOne());
		System.ln();

		match (code.ast) {
			Lit(val) => value = val;
			Id(id) => {
				if (locals.has(id)) {
					value = locals[id];
				} else if (globals.has(id)) {
					value = globals[id];
				} else {
					throw(StrObjects.getStrObject(Strings.format1("unbound identifier: %s", id)));
				}
			}
			Apply(tgt, args) => {
				def tgtVal = eval(tgt);
				if (exn) return value;
				assertType(FuncObjects.classFunc, tgtVal);
				if (exn) return value;

				// function code
				def fv = FuncObject.!(tgtVal);
				def params = fv.func.params, code = fv.func.code;

				// evaluate argument values
				var argv: Array<Object> = Array.new(args.length);
				for (i < argv.length) {
					def arg = eval(args[i]);
					if (exn) return value;
					argv[i] = arg;
				}

				// arity check
				assertArity(params.length, argv);
				if (exn) return value;

				// create locals
				def newLocals: HashMap<string, Object> = Strings.newMap();
				for (i < argv.length) {
					newLocals[params[i]] = argv[i];
				}

				// if this is a method, insert extra locals or arguments
				if (fv.instanceOf(MethodObjects.classMethod)) {
					newLocals["self"] = MethodObject.!(fv).obj;
					argv = Arrays.prepend(MethodObject.!(fv).obj, argv);					
				}

				// create new frame (and evaluate)
				System.puts(Strings.format1("Creating frame for: %s\n", fv.func.id));
				def frame = Frame.new(this, newLocals, argv, code);
				System.puts("done\n");
				if (frame.exn) {
					// record stacktrace
					stacktrace.puta(frame.stacktrace.extract());
					// rethrow
					throw(frame.val);
					return value;
				}
				value = frame.val;
			}
			If(exprC, exprT, exprF) => {
				def cond = eval(exprC);
				if (exn) return value;

				if (cond.isTrue()) {
					def v = eval(exprT);
					if (exn) return value;
					value = v;
				} else {
					def v = eval(exprF);
					if (exn) return value;
					value = v;
				}
			}
			Raise(expr) => {
				def v = eval(expr);
				if (exn) return value;

				throw(v);
			}
			Catch(try, exnvar, catch) => {
				def v = eval(try);
				if (!exn) {
					value = v;
				} else {
					// catch exception
					exn = false;
					locals[exnvar] = val; // bind exception to variable
					def e = eval(catch);
					if (exn) return value;
					value = e;
				}
			}
			Func(id, params, code) => {
				def c = CodeObject.new(code);
				def f = FuncObjects.newFO(Func.new(id, params, c.code));
				locals[id] = f;
				value = f;
			}
			Class(id, superclass, init, fields, methods) => {
				var i: Code = if(init.isJust(), init.fromJust(), null);
				var s: Class;
				match (superclass) {
					Just(e) => {
						var v = eval(e);
						if (exn) return value;
						
						assertType(ClassObjects.classClass, v);
						if (exn) return value;
						
						s = ClassObject.!(v).clazz;
					}
					Nothing => s = Objects.classBase;
				}
				def f: Array<(string, Code)> = fields;
				def m: Array<Func> = Arrays.map(methods, funcToFunc);
				def c = ClassObject.new(Class.new(id, s, i, f, m));
				locals[id] = c;
				value = c;
			}
			Assign(id, expr) => {
				def v = eval(expr);
				if (exn) return value;
				locals[id] = v;
				value = v;
			}
			Cond(cases) => {
				var sat = false;
				for (c in cases) {
					// case
					def cond = c.0, expr = c.1;

					// check cond
					def t = eval(cond);
					if (exn) return value;
					if (t.isTrue()) {
						def v = eval(expr);
						if (exn) return value;
						value = v;

						sat = true;
						break;
					}
				}

				if (!sat) {
					throw(StrObjects.getStrObject("cond error: no true branch"));
				}
			}
			While(cond, body) => {
				while (true) {
					def v = eval(cond);
					if (exn) return value;

					if (!v.isTrue()) {
						value = v;
						break;
					}

					eval(body);
					if (exn) return value;
				}
			}
			Begin(exprs) => {
				var last: Object;
				for (expr in exprs) {
					def v = eval(expr);
					if (exn) return value;

					last = v;
				}
				value = last;
			}
			GetField(field, expr) => {
				var obj = eval(expr);
				if (exn) return value;

				match (obj.getField(field)) {
					Just(v) => value = v;
				} else {
					throw(StrObjects.getStrObject(Strings.format1("name error: unknown field %s", field)));
					return value;
				}
			}
			SetField(field, expr, newCode) => {
				var obj = eval(expr);
				if (exn) return value;

				var val = eval(newCode);
				if (exn) return value;

				value = obj.fields[field];
				if (obj.fields.has(field)) {
					obj.fields[field] = val;
					value = val;
				} else {
					throw(StrObjects.getStrObject(Strings.format1("name error: unknown field %s", field)));
					return value;
				}
			}
			New(expr) => {
				var cls = eval(expr);
				if (exn) return value;

				assertType(ClassObjects.classClass, cls);
				if (exn) return value;

				def clsObj = ClassObject.!(cls);
				def obj = Object.new(clsObj.clazz);

				def classes: Vector<Class> = Vector.new();
				for (cls = clsObj.clazz; cls != null; cls = cls.superclass)
					classes.put(cls);
			
				// initialization order is from base class downwards, which
				// may involve reinitializing some fields
				for (cls in classes.reverse().extract()) {
					// initialize fields
					for (field in cls.classFields) {
						def name = field.0, expr = field.1;

						// XXX hackfix
						if (expr == null) continue;
						// create new frames here!
						def frame = Frame.new(this, Strings.newMap(), [], expr);
						if (frame.exn) {
							// record stacktrace
							stacktrace.puta(frame.stacktrace.extract());
							// rethrow
							throw(frame.val);
							return value;
						}
						obj.fields[name] = frame.val;
					}
					// call initializer
					if (cls.init != null) {
						//System.puts(Strings.format1("> %s\n", cls.name));
						def code = cls.init;

						def newLocals: HashMap<string, Object> = Strings.newMap();
						newLocals["self"] = obj;
						def argv: Array<Object> = [obj];

						// create new frames here!
						def frame = Frame.new(this, newLocals, argv, code);
						if (frame.exn) {
							// record stacktrace
							stacktrace.puta(frame.stacktrace.extract());
							// rethrow
							throw(frame.val);
							return value;
						}
						value = frame.val; // why?
					} 
				}

				return obj; // why?
			}
		}

		return value;
	}
	
	/* BYTECODE EVALUATOR */
	def tier1Eval(c: Code) -> Object {
		System.puts("tier1Eval\n");
		def code       = c.bytecode.copy();
		def strings    = c.strings;
		def classholes = c.classholes;
		def constants  = c.constants;

		// Bytecodes.inspect(code);

		// FIXME this valuestack thing should be in the Frame
		// big idea: perhaps each tier should extend Frame (so it can all be separate!)?
		def stack: ArrayStack<Object> = ArrayStack.new();
		def handlers: Stack<int> = ArrayStack.new();

		var pc = 0;
		while (pc < code.length) {
			def bytecode = Ref<Bytecode>.at(code, pc);
			def opcode   = bytecode.opcode;
			def operand  = bytecode.operand;

			//System.puts(Strings.format3("+%d: %s %d\n", pc, opcode.name, operand));
			//System.puts("stack:\n");
			//for (i < stack.top) {
			//	System.puts(stack.elems[i].display());
			//	System.ln();
			//}
			//System.puts("--\n");

			pc += 2;
			match (opcode) {
				LOAD_LIT => stack.push(constants[operand]);
				LOAD_NAME => {
					def id = strings[operand];
					// XXX this duplicates tier0 code, refactor away (using OO approach)
					if (locals.has(id)) {
						stack.push(locals[id]);
					} else if (globals.has(id)) {
						stack.push(globals[id]);
					} else {
						throw(StrObjects.getStrObject(Strings.format1("unbound identifier: %s", id)));
						if (!handlers.empty()) {
							pc = handlers.pop();
							exn = false;
						} else {
							return null;
						}
					}
				}
				JUMP => pc += i8.view(operand);
				JUMP_IF_FALSE => {
					def top = stack.pop();
					if (!top.isTrue()) pc += i8.view(operand);
				}
				JUMP_IF_FALSE_PEEK => {
					def top = stack.peek();
					if (top.isTrue()) {
						stack.pop();
					} else {
						pc += i8.view(operand);
					}
				}
				RAISE => {
					def top = stack.pop();
					throw(top);
					if (!handlers.empty()) {
						pc = handlers.pop();
						exn = false;
					} else {
						return null;
					}
				}
				STORE_NAME => {
					def id = strings[operand];
					def top = stack.pop();
					locals[id] = top;
				}
				ASSERT_FUNC => {
					def top = stack.peek();
					assertType(FuncObjects.classFunc, top);
					if (exn)
						if (!handlers.empty()) {
							pc = handlers.pop();
							exn = false;
						} else {
							return null;
						}
				}
				CALL => {
					var args: Vector<Object> = Vector.new();
					for (i < operand) {
						args.put(stack.pop());
					}
					args.reverse();
					var argv: Array<Object> = args.extract();

					def top = stack.pop();
					// function code
					def fv = FuncObject.!(top); // this cast succeeds because of ASSERT_FUNC
					def params = fv.func.params, code = fv.func.code;

					// arity check
					assertArity(params.length, argv);
					if (exn)
						if (!handlers.empty()) {
							pc = handlers.pop();
							exn = false;
						} else {
							return null;
						}

					// create locals
					def newLocals: HashMap<string, Object> = Strings.newMap();
					for (i < argv.length) {
						newLocals[params[i]] = argv[i];
					}

					// if this is a method, insert extra locals or arguments
					if (fv.instanceOf(MethodObjects.classMethod)) {
						newLocals["self"] = MethodObject.!(fv).obj;
						argv = Arrays.prepend(MethodObject.!(fv).obj, argv);					
					}

					// create new frame (and evaluate)
					def frame = Frame.new(this, newLocals, argv, code);
					if (frame.exn) {
						// record stacktrace
						stacktrace.puta(frame.stacktrace.extract());
						// rethrow
						throw(frame.val);
						if (!handlers.empty()) {
							pc = handlers.pop();
							exn = false;
						} else {
							return null;
						}
					}

					stack.push(frame.val);
				}
				TRY => {
					handlers.push(pc + operand);
				}
				CATCH => {
					handlers.pop();
				}
				PULL => for (i < operand) stack.pop();
				// objects
				CREATE_CLASS => {
					def superclass = stack.pop();
					assertType(ClassObjects.classClass, superclass);
					if (exn)
						if (!handlers.empty()) {
							pc = handlers.pop();
							exn = false;
						} else {
							return null;
						}

					def classhole = classholes[operand];
					stack.push(ClassObject.new(Class.new(classhole.name, ClassObject.!(superclass).clazz, classhole.init, classhole.classFields, classhole.classMethods)));
				}
				NEW => {
					def top = stack.pop();
					assertType(ClassObjects.classClass, top);
					if (exn)
						if (!handlers.empty()) {
							pc = handlers.pop();
							exn = false;
						} else {
							return null;
						}

					// duplicated code
					def clsObj = ClassObject.!(top);
					def obj = Object.new(clsObj.clazz);

					def classes: Vector<Class> = Vector.new();
					for (cls = clsObj.clazz; cls != null; cls = cls.superclass)
						classes.put(cls);
				
					// initialization order is from base class downwards, which
					// may involve reinitializing some fields
					for (cls in classes.reverse().extract()) {
						// initialize fields
						for (field in cls.classFields) {
							def name = field.0, expr = field.1;

							// XXX hackfix
							if (expr == null) continue;
							// create new frames here!
							def frame = Frame.new(this, Strings.newMap(), [], expr);
							if (frame.exn) {
								// record stacktrace
								stacktrace.puta(frame.stacktrace.extract());
								// rethrow
								throw(frame.val);
								if (!handlers.empty()) {
									pc = handlers.pop();
									exn = false;
								} else {
									return null;
								}
							}
							obj.fields[name] = frame.val;
						}
						// call initializer
						if (cls.init != null) {
							//System.puts(Strings.format1("> %s\n", cls.name));
							def code = cls.init;

							def newLocals: HashMap<string, Object> = Strings.newMap();
							newLocals["self"] = obj;
							def argv: Array<Object> = [obj];

							// create new frames here!
							def frame = Frame.new(this, newLocals, argv, code);
							if (frame.exn) {
								// record stacktrace
								stacktrace.puta(frame.stacktrace.extract());
								// rethrow
								throw(frame.val);
								if (!handlers.empty()) {
									pc = handlers.pop();
									exn = false;
								} else {
									return null;
								}
							}
						}
					}
					stack.push(obj);
				}
				GET_FIELD => {
					def obj = stack.pop();
					def field = strings[operand];

					match (obj.getField(field)) {
						Just(v) => stack.push(v);
					} else {
						throw(StrObjects.getStrObject(Strings.format1("name error: unknown field %s", field)));
						if (!handlers.empty()) {
							pc = handlers.pop();
							exn = false;
						} else {
							return null;
						}
					}

				}
				SET_FIELD => {
					def val = stack.pop();
					def obj = stack.pop();
					def field = strings[operand];

					if (obj.fields.has(field)) {
						obj.fields[field] = val;
						stack.push(val);
					} else {
						throw(StrObjects.getStrObject(Strings.format1("name error: unknown field %s", field)));
						if (!handlers.empty()) {
							pc = handlers.pop();
							exn = false;
						} else {
							return null;
						}
					}
				}

			//	_ => System.error("eval error", "unsupported opcode");
			}
		}

		return stack.peek();
	}
	
	def display() -> string { return "<frame>"; }
	def isTrue()  -> bool   { return true; }

	/* throwing exceptions */

	// throw sets the exception value in the frame right away
	private def throw(value: Object) {
		stacktrace.put(null); // FIXME figure out proper error reporting for tier1
		exn = true;
		val = value;
	}

	private def assertType(exp: Class, val: Object) {
		if (!val.instanceOf(exp))
			throw(StrObjects.getStrObject(Strings.format2("type mismatch: expected %s, got %s", exp.display(), val.cls.display())));
	}

	private def assertArity(argc: int, vals: Range<Object>) {
		if (vals.length != argc)
			throw(StrObjects.getStrObject(Strings.format2("arity mismatch: expected %d, got %d", argc, vals.length)));
	}

}


def funcToFunc(f: AST.Func) -> Func {
	// FIXME null
	return Func.new(f.id, f.params, Codes.fromAST(f, null));	
}



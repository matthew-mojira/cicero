class FrameObject(prev: FrameObject, locals: HashMap<string, Object>, code: CodeObject) extends Object {
	var globals: HashMap<string, Object>;

	// you could replace this with a higher-tier evaluation function
	// TODO code doesn't have to be AST
	var evalFunc: Code -> Object;

	// status flags as the result of evaluation
	var exn: bool = false;  // whether evaluation threw uncaught exception
	var val: Object;         // result of evaluation or exception value

	/* Initializing the frame also evaluates it (except for top-level frames). */
	new() super(FrameObjects.classFrame) {
		evalFunc = tier0Eval;
		if (prev == null) {
			// this is the top-level frame, where locals = globals
			globals = locals;
		} else {
			globals = prev.globals;

			// evaluate the frame
			def v = evalFunc(code.code);
			if (!exn)
				val = v;
		}
	}

	// special function for top-level frame to let it evaluate multiple expressions 
	def eval(expr: Code) {
		if (prev != null) System.error("eval error", "attempted to evaluate expression not in top level");

		def v = evalFunc(expr);
		if (!exn)
			val = v;
		// XXX no return value, inspect the frame instead
	}

	private def tier0Eval(code: Code) -> Object {
		var value: Object;

		match (code.ast) {
			Lit(val) => value = val;
			Id(id) => {
				if (locals.has(id)) {
					value = locals[id];
				} else if (globals.has(id)) {
					value = globals[id];
				} else {
					throw(StrObjects.getStrObject(Strings.format1("unbound identifier: %s", id)));
				}
			}
			Apply(tgt, args) => {
				def tgtVal = tier0Eval(tgt);
				// remember: these are recursive calls within `tier0Eval` but
				// have nothing to do with evaluation frames in the language
				if (exn) return value;
				// FIXME improve type checking
				if (!FuncObject.?(tgtVal)) {
					assertType(Type.Func, tgtVal);
					return value;
				}

				def argv: Array<Object> = Array.new(args.length);
				for (i < argv.length) {
					def arg = tier0Eval(args[i]);
					if (exn) return value;
					argv[i] = arg;
				}

				// function call
				def fv = FuncObject.!(tgtVal);
				def params = fv.params, code = fv.code;

				// arity check
				assertArity(params.length, argv);
				if (exn) return value;

				def newLocals: HashMap<string, Object> = Strings.newMap();
				// method info
				if (MethodObject.?(fv)) {
					// FIXME magic string
					newLocals["self"] = MethodObject.!(fv).obj;
				}
				// arguments
				for (i < argv.length) {
					newLocals[params[i]] = argv[i];
				}

				if (code.code.tier >= 0) {
					// create new frames here!
					def frame = FrameObject.new(this, newLocals, code);
					if (frame.exn) {
						// rethrow
						throw(frame.val);
						return value;
					}
					value = frame.val;
				} else {
					// virgil source
					// if this is a method, add the object as the first argument
					var vArgv = argv;
					if (MethodObject.?(fv)) {
						vArgv = Arrays.prepend(MethodObject.!(fv).obj, argv);					
					}
					// function call
					def func = code.code.virgil;
					def ret = func(vArgv);
					def val = ret.0, fnExn = ret.1;

					if (fnExn) {
						throw(val);
						return value;
					} else {
						value = val;
					}	
				}
			}
			If(exprC, exprT, exprF) => {
				def cond = tier0Eval(exprC);
				if (exn) return value;

				if (cond.isTrue()) {
					def v = tier0Eval(exprT);
					if (exn) return value;
					value = v;
				} else {
					def v = tier0Eval(exprF);
					if (exn) return value;
					value = v;
				}
			}
			Raise(expr) => {
				def v = tier0Eval(expr);
				if (exn) return value;

				throw(v);
			}
			Catch(try, catch) => {
				def v = tier0Eval(try);
				if (!exn) {
					value = v;
				} else {
					// catch exception
					exn = false;
					def e = tier0Eval(catch);
					if (exn) return value;
					value = e;
				}
			}
			Func(id, params, code) => {
				def c = CodeObject.new(code);
				def f = FuncObject.new(id, params, c);
				locals[id] = f;
				value = f;
			}
			Class(id, superclass, init, fields, methods) => {
				var i: CodeObject = if(init.isJust(), CodeObject.new(init.fromJust()), null);
				var s: ClassObject = Objects.classBase;
				// TODO match on {superclass} and evaluate expression
				def f: Array<(string, CodeObject)> = Arrays.map(fields, codeToCodeObject);
				def m: Array<FuncObject> = Arrays.map(methods, funcToFuncObject);
				def c = ClassObject.new(id, s, i, f, m);
				locals[id] = c;
				value = c;
			}
			Assign(id, expr) => {
				def v = tier0Eval(expr);
				if (exn) return value;
				locals[id] = v;
				value = v;
			}
			Cond(cases) => {
				var sat = false;
				for (c in cases) {
					// case
					def cond = c.0, expr = c.1;

					// check cond
					def t = tier0Eval(cond);
					if (exn) return value;
					if (t.isTrue()) {
						def v = tier0Eval(expr);
						if (exn) return value;
						value = v;

						sat = true;
						break;
					}
				}

				if (!sat) {
					throw(StrObjects.getStrObject("cond error: no true branch"));
				}
			}
			While(cond, body) => {
				while (true) {
					def v = tier0Eval(cond);
					if (exn) return value;

					if (!v.isTrue()) {
						value = v;
						break;
					}

					tier0Eval(body);
					if (exn) return value;
				}
			}
			Begin(exprs) => {
				var last: Object;
				for (expr in exprs) {
					def v = tier0Eval(expr);
					if (exn) return value;

					last = v;
				}
				value = last;
			}
			GetField(field, expr) => {
				var obj = tier0Eval(expr);
				if (exn) return value;

				match (obj.getField(field)) {
					Just(v) => value = v;
				} else {
					throw(StrObjects.getStrObject(Strings.format1("name error: unknown field %s", field)));
					return value;
				}
			}
			SetField(field, expr, newCode) => {
				var obj = tier0Eval(expr);
				if (exn) return value;

				var val = tier0Eval(newCode);
				if (exn) return value;

				value = obj.fields[field];
				if (obj.fields.has(field)) {
					obj.fields[field] = val;
					value = val;
				} else {
					throw(StrObjects.getStrObject(Strings.format1("name error: unknown field %s", field)));
					return value;
				}
			}
			New(expr) => {
				var cls = tier0Eval(expr);
				if (exn) return value;

				assertType(Type.Class, cls);
				if (exn) return value;

				def clsObj = ClassObject.!(cls);
				def obj = ObjectObject.new(clsObj);

				// initialize fields in superclass order
				def classes: Vector<ClassObject> = Vector.new();
				for (cls = clsObj; cls != null; cls = cls.superclass)
					classes.put(cls);
				
				for (cls in classes.extract()) {
					// initialize fields
					for (field in cls.classFields) {
						def name = field.0, expr = field.1;
						// FIXME this is incorrect if a child class overrides a field with a method
						if (obj.fields.has(name)) continue;

						// XXX hackfix
						if (expr == null) continue;
						var v = tier0Eval(expr.code);
						if (exn) return value;
						obj.fields[name] = v;
					}
					// initialize methods?
// 					for (func in cls.classMethods) {
// 						if (obj.fields.has(func.id)) continue;
// 						def m = MethodObject.new(obj, func.id, func.params, func.code);
// 						obj.fields[func.id] = m;
// 					}
					// call initializer
					if (cls.init != null) {
						def code = cls.init;
						if (code.code.tier >= 0) {
							// create new frames here!
							def newLocals: HashMap<string, Object> = Strings.newMap();
							newLocals["self"] = obj;

							def frame = FrameObject.new(this, newLocals, code);
							if (frame.exn) {
								// rethrow
								throw(frame.val);
								return value;
							}
							value = frame.val;
						} else {
							// function call
							def func = code.code.virgil;
							def ret = func([obj]);
							def val = ret.0, fnExn = ret.1;

							if (fnExn) {
								throw(val);
								return value;
							} else {
								value = val;
							}	
						}
					}
					System.ln();
				}

				return obj;
			}
		}

		return value;
	}
	
	def typeof()  -> Type   { return Type.Frame; }
	def display() -> string { return "<frame>"; }
	def isTrue()  -> bool   { return true; }

	/* throwing exceptions */

	// throw sets the exception value in the frame right away
	private def throw(value: Object) {
		exn = true;
		val = value;
	}

	private def assertType(exp: Type, val: Object) {
		if (exp != val.typeof())
			throw(StrObjects.getStrObject(Strings.format2("type mismatch: expected %s, got %s", exp.display(), val.typeof().display())));
	}

	private def assertArity(argc: int, vals: Range<Object>) {
		if (vals.length != argc)
			throw(StrObjects.getStrObject(Strings.format2("arity mismatch: expected %d, got %d", argc, vals.length)));
	}

}

component FrameObjects {
	def classFrame = ClassObject.new("frame", Objects.classBase, null, [], []);
}

def codeToCodeObject(p: (string, Code)) -> (string, CodeObject) {
	return (p.0, CodeObject.new(p.1));
}

def funcToFuncObject(f: AST.Func) -> FuncObject {
	return FuncObject.new(f.id, f.params, CodeObject.new(f.body));	
}



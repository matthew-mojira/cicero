/* An integer object, backed by a BigInteger.
 *
 * Note: integers aren't canonicalized, so there can be multiple distinct
 * Virgil objects floating around that represent the same underlying number.
 */
class IntObject(val: BigInteger) extends Object {
	def display() => val.displayDec();
	def isTrue()  => true;

	/* METHODS */

	/* arithmetic */
	def i_neg()  => Result.OK(IntObject.new(val.negate()));

	def i_add(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return Result.OK(IntObject.new(this.val.add(iobj.val)));
		}
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dobj = DoubleObject.!(obj);
			return DoubleIntOperations.addIntDouble(this, dobj);
		}
		return Result.Exn(ExnObjects.fromVirgil("+", "Can only perform '+' on an `int` with another `int` or `double`"));
	}

	def i_sub(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return Result.OK(IntObject.new(this.val.subtract(iobj.val)));
		}
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dobj = DoubleObject.!(obj);
			return DoubleIntOperations.subIntDouble(this, dobj);
		}
		return Result.Exn(ExnObjects.fromVirgil("-", "Can only perform '-' on an `int` with another `int` or `double`"));
	}

	def i_mul(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return Result.OK(IntObject.new(this.val.multiply(iobj.val)));
		}
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dobj = DoubleObject.!(obj);
			return DoubleIntOperations.mulIntDouble(this, dobj);
		}
		return Result.Exn(ExnObjects.fromVirgil("*", "Can only perform '*' on an `int` with another `int` or `double`"));
	}

	def i_div(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classInt)){
			def iobj = IntObject.!(obj);
			return if (iobj.val.signum == 0, 
				Result.Exn(ExnObjects.fromVirgil("int.div", divideByZero)),
				Result.OK(IntObject.new(this.val.divide(iobj.val))));
		}
		if (obj.instanceOf(ClassObjects.classDouble)){
			def dobj = DoubleObject.!(obj);
			return DoubleIntOperations.divIntDouble(this, dobj);
		}
		return Result.Exn(ExnObjects.fromVirgil("/", "Can only perform '/' on an `int` with another `int` or `double`"));
	}

	def i_mod(that: IntObject) => if (that.val.signum == 0,
			Result.Exn(ExnObjects.fromVirgil("int.mod", divideByZero)),
			Result.OK(IntObject.new(this.val.remainder(that.val))));

	/* comparisons */
	def i_eq(that: Object) -> Result {
		if (!that.instanceOf(ClassObjects.classInt))
			return Result.OK(BoolObjects.falseObject);
		return Result.OK(BoolObjects.fromBool(this.val.equals(IntObject.!(that).val)));
	}

	def i_lt(that: IntObject)  => Result.OK(BoolObjects.fromBool(this.val.compareTo(that.val) <  0));
	def i_leq(that: IntObject) => Result.OK(BoolObjects.fromBool(this.val.compareTo(that.val) <= 0));
	def i_gt(that: IntObject)  => Result.OK(BoolObjects.fromBool(this.val.compareTo(that.val) >  0));
	def i_geq(that: IntObject) => Result.OK(BoolObjects.fromBool(this.val.compareTo(that.val) >= 0));

	/* logical */
	def i_and(that: IntObject) => Result.OK(IntObject.new(this.val.and(that.val)));
	def i_ora(that: IntObject) => Result.OK(IntObject.new(this.val.or(that.val)));
	def i_eor(that: IntObject) => Result.OK(IntObject.new(this.val.xor(that.val)));
	def i_shl(that: IntObject) => Result.OK(IntObject.new(this.val.shiftLeft(int.view(that.val.longValue()))));
	def i_shr(that: IntObject) => Result.OK(IntObject.new(this.val.shiftRight(int.view(that.val.longValue()))));

	def i_display() => Result.OK(StrObjects.fromString(display()));
}


component IntObjects {
	def fromLong(val: long) => IntObject.new(BigIntegers.fromLong(val));
}

def divideByZero = "division by zero";

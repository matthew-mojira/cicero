class IntObject(val: long) extends Object {
	private new() super(IntObjects.classInt) {}

	def display() -> string { return Strings.format1("%d", val); }
	def isTrue()  -> bool   { return true; }
}

def i_display(vals: Range<Object>) -> (Object, bool) {
	return (StrObjects.getStrObject(Strings.format1("%d", IntObject.!(vals[0]).val)), false);
}

def i_istrue(vals: Range<Object>) -> (Object, bool) {
	return (BoolObjects.trueObject, false);
}

component IntObjects {
	def classInt = ClassObject.new("int", Objects.classBase, null, [], []);

	/* canonicalize int value instances */
	def intObjects = HashMap<long, IntObject>.new(int.!, long.==);
	def getIntObject(val: long) -> IntObject {
		if (intObjects.has(val)) return intObjects[val];
		def newInt = IntObject.new(val);
		intObjects[val] = newInt;
		return newInt;
	}

	/* arithmetic operations on int values */
	def add(int1: IntObject, int2: IntObject) -> IntObject {
		return getIntObject(int1.val + int2.val);
	}
	def sub(int1: IntObject, int2: IntObject) -> IntObject {
		return getIntObject(int1.val - int2.val);
	}
	def mul(int1: IntObject, int2: IntObject) -> IntObject {
		return getIntObject(int1.val * int2.val);
	}
	// TODO what to do if this fails?
	def div(int1: IntObject, int2: IntObject) -> IntObject {
		return getIntObject(int1.val / int2.val);
	}
}

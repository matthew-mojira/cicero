class IntObject(val: long) extends Object {
	private new () {
		fields["typeof"]  = TypeObjects.getTypeObject(Type.Int);
		fields["display"] = MethodObjects.fromBuiltin(this, 0, i_display);
		fields["istrue"]  = MethodObjects.fromBuiltin(this, 0, i_istrue);
	}

	def typeof()  -> Type   { return Type.Int; }
	def display() -> string { return Strings.format1("%d", val); }
	def isTrue()  -> bool   { return true; }
}

def i_display(vals: Range<Object>) -> (Object, bool) {
	return (StrObjects.getStrObject(Strings.format1("%d", IntObject.!(vals[0]).val)), false);
}

def i_istrue(vals: Range<Object>) -> (Object, bool) {
	return (BoolObjects.trueObject, false);
}

component IntObjects {
	/* canonicalize int value instances */
	def intObjects = HashMap<long, IntObject>.new(int.!, long.==);
	def getIntObject(val: long) -> IntObject {
		if (intObjects.has(val)) return intObjects[val];
		def newInt = IntObject.new(val);
		intObjects[val] = newInt;
		return newInt;
	}

	/* arithmetic operations on int values */
	def add(int1: IntObject, int2: IntObject) -> IntObject {
		return getIntObject(int1.val + int2.val);
	}
	def sub(int1: IntObject, int2: IntObject) -> IntObject {
		return getIntObject(int1.val - int2.val);
	}
	def mul(int1: IntObject, int2: IntObject) -> IntObject {
		return getIntObject(int1.val * int2.val);
	}
	// TODO what to do if this fails?
	def div(int1: IntObject, int2: IntObject) -> IntObject {
		return getIntObject(int1.val / int2.val);
	}
}

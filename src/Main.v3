def main(args: Array<string>) -> int {
	def files = CLOptions.parse(args);

	if (CLOptions.VERSION.get()) {
		printVersion();
		printBuildData();

		return 0;
	}
	if (CLOptions.HELP.get()) {
		printVersion();
		printBuildData();
		printHelp();

		return 0;
	}

	def tier = CLOptions.TIER.get();
	if (tier < 0 || tier > 2) {
		System.error("argument error", Strings.format1("unrecognized tier: %d", tier));
		return 1;
	}

	def frame = FrameObjects.newTopFrame();
	loadCore(frame);

	def FAILURE = if(CLOptions.FUZZING.get(), 0, 1);
	
	// evaluate files (if present)
	for (filename in files) {
		// read in file
		def file = System.fileLoad(filename);
		if (file == null) {
			System.puts(Strings.format1("init error: unable to load file %s", filename));
			System.error("init error", Strings.format1("unable to load file %s", filename));
		}
		// parse
		var reader = Parser.new(filename, file);
		if (reader.ok) {
			if (CLOptions.CHECK_SYNTAX.get()) continue;
			def exprs = reader.getExprs();
			for (expr in exprs) {
				// compile to bytecode if necessary
				if (CLOptions.TIER.get() > 0) expr.compile([]);

				// evaluate
				frame.evalCode(expr);
				match (frame.result) {
					Exn(exn) => {
						exn.print();
						return FAILURE;
					}
					OK(val) => {
						if (!CLOptions.SUPPRESS_OUTPUT.get()) 
							System.puts(Strings.format1("=> %s\n", val.display()));
					}
					_ => {
						System.error("eval error", "frame did not give result");
						return 1;
					}
				}
			}
		} else {
			def sb = StringBuilder.new();
// 
// 			for (err in reader.errors.copy()) {
// 				sb.puts(reader.fileName);
// 				sb.put3(":%d:%d: parse error: %s\n", err.0, err.1, err.2);
// 				sb.ln();
// 			}

			sb.puts(reader.fileName);
			sb.put3(":%d:%d: parse error: %s\n", reader.error_line, reader.error_column, reader.error_msg);
			reader.renderCurrentLineWithCaret(sb, reader.error_column);
			sb.ln();

 			System.puts(sb.extract());
			return FAILURE;
		}
	}

	// run repl (if requested)
	if (files.length == 0 || CLOptions.REPL.get()) {
		var scanner = Scanner.new();
		while (true) {
			System.puts("cicero> ");
			var reader = Parser.new("<repl>", scanner.nextLine());
			if (reader.ok) {
				def exprs = reader.getExprs();

				for (expr in exprs) {
					// compile to bytecode if necessary
					if (CLOptions.TIER.get() > 0) expr.compile([]);

					// evaluate
					frame.evalCode(expr);
					match (frame.result) {
						Exn(exn) => {
							System.puts("Exception\n");
							exn.print();
							frame.resetExn();
						}
						OK(val) => {
							if (val == null)
								System.puts("result value was null\n");
							System.puts(Strings.format1("=> %s\n", val.display()));
						}
						_       => System.error("eval error", "frame did not give result");
					}
				}
			} else {
				System.puts(Strings.format1("parse error: %s\n", reader.error_msg));
				def sb = StringBuilder.new();
				reader.renderCurrentLineWithCaret(sb, reader.error_column);
				System.puts(sb.extract());
				System.ln();
			}
		}
	}

	if (CiceroOptions.profileBytecode) {
		/* Output Cicero's profiling */
		var i = 0;
		for (op in Opcode.set.all) {
			System.puts(Strings.format2("%s: %d\n", op.name, Profiling.bytecodeMap[i++]));
		}
	}


	return 0;
}

def loadCore(frame: FrameObject) {
	def reader = Parser.new("core", CiceroTexts.core);
	def exprs = reader.getExprs();
	for (expr in exprs) {
 		if (CLOptions.TIER.get() > 0) {
 			expr.compile([]);
		}
		frame.evalCode(expr);
	}
}

def printVersion() {
	System.puts(Strings.format2("Cicero %s.%d\n", Version.version, Version.minorVersion));
}
def printBuildData() {
	System.puts(Strings.format1("Build data: %s\n", Version.buildData));
}
def printHelp() {
	System.puts("Usage: cicero [options]\n");
	System.puts("Usage: cicero [options] <.co files>\n");
	System.ln();
	CLOptions.print();
}

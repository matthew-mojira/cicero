class Object(cls: ClassObject) {
	def var fields: HashMap<string, Object> = Strings.newMap();
	def var lazyFields: HashMap<string, Field.LazyMethod> = Strings.newMap();

	new() {
		// Object initializes lazy fields (methods)
		for (cls = this.cls; cls != null; cls = cls.superclass) {
			for (field in cls.classFields) {
				match (field) {
					LazyMethod(name, _, _) => {
						if (lazyFields.has(name)) continue;
						lazyFields[name] = Field.LazyMethod.!(field);
					}
					_ => ;
				}
			}

		}
	}

	/* Some fields are lazily bound.
	 */
	def getField(name: string) -> Maybe<Object> {
		if (fields.has(name)) return Maybe.Just(fields[name]);
		// Some fields are lazily bound.
		if (lazyFields.has(name)) {
			def field = lazyFields[name];
			def obj = MethodObjects.fromBuiltin(this, field.paramc, field.method);
			fields["fields"] = obj;
			return Maybe.Just(obj);
		}
		return Maybe.Nothing;
	}

	def typeof() -> Type;
	def display() -> string;
	def isTrue() -> bool;

}

component Objects {
	def classBase = ClassObject.new(null, "base", [Field.LazyMethod("fields", 0, o_fields)]);
}

def o_fields(args: Range<Object>) -> (Object, bool) {
	def obj = args[0];
	def list = ListObject.new();
	def fList = Maps.keyList(obj.fields);
	// FIXME add lazy fields
	Lists.apply(fList, putList(list, _));
	return (list, false);
}

def putList(list: ListObject, str: string) {
	def obj = StrObjects.getStrObject(str);
	list.list.put(obj);
}

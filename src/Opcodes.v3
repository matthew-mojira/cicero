enum OperandType {
	NONE, SLEB, ULEB
}

enum Opcode(operandType: OperandType) {
	NOP                  (OperandType.NONE),
	// Loads
	LOAD_CONST           (OperandType.ULEB),   // [0] index into the constant pool
	LOAD_GLOBAL          (OperandType.ULEB),   // [0] index into the string pool
	LOAD_LOCAL           (OperandType.ULEB),   // [0] index into the runtime locals
	LOAD_FIELD           (OperandType.ULEB),   // [1] index into the string pool
	// Stores
	STORE_GLOBAL         (OperandType.ULEB),   // [1] index into the string pool
	STORE_LOCAL          (OperandType.ULEB),   // [0] index into the runtime locals
	STORE_FIELD          (OperandType.ULEB),   // [2] index into the string pool
	// Control flow
	CALL                 (OperandType.ULEB),   // [n] number of arguments (not including function!)
	JUMP                 (OperandType.SLEB),   // [0] offset of pc
	JUMP_IF_FALSE        (OperandType.SLEB),   // [1] offset of pc
	JUMP_IF_TRUE_PEEK    (OperandType.SLEB),   // [1] offset of pc
	JUMP_IF_FALSE_PEEK   (OperandType.SLEB),   // [1] offset of pc
	// Exceptions
	RAISE                (OperandType.NONE),   // [1]
	TRY                  (OperandType.SLEB),   // [0] offset from this bytecode of the catch
	CATCH                (OperandType.NONE),   // [0]
	ASSERT_FUNC          (OperandType.NONE),   // [1]
	// Object creation
	CREATE_CLASS         (OperandType.ULEB),   // [1] index into the classhole pool
	CREATE_OBJECT        (OperandType.NONE),   // [1]
	CREATE_LIST          (OperandType.ULEB),   // [1] how many elements to pull
	// Stack manipulation
	POP                  (OperandType.ULEB),   // [1] how many values to pull
	DUPE                 (OperandType.ULEB),   // index of element to dupe to top of stack (0 = top)
	SWAP                 (OperandType.ULEB)    // index of element to swap top of stack with (0 = top)
}

/* TODO Defining a better format for bytecode:
 * Right now, each bytecode is four bytes: one for the opcode and three for the
 * operand. While the alignment is nice, this is really wasteful; rarely does
 * an instruction need the third byte, and some don't take operands at all.
 *
 * Instead of using EXTENDED_ARG like CPython, we should use an LEB128 encoding
 * from Wasm (which Virgil has library functions to support).
 *
 * Each opcode:
 *   NOP
 *   LOAD_CONST         uleb
 *   LOAD_GLOBAL        uleb
 *   LOAD_LOCAL         uleb
 *   LOAD_FIELD         uleb
 *   STORE_GLOBAL       uleb
 *   STORE_LOCAL        uleb
 *   STORE_FIELD        uleb
 *   CALL               uleb
 *   JUMP               sleb
 *   JUMP_IF_FALSE      sleb
 *   JUMP_IF_TRUE_PEEK  sleb
 *   JUMP_IF_FALSE_PEEK sleb
 *   RAISE
 *   TRY                sleb
 *   CATCH
 *   ASSERT_FUNC
 *   CREATE_CLASS       uleb
 *   CREATE_OBJECT
 *   CREATE_LIST        uleb
 *   POP                uleb
 *   DUPE               uleb
 *   SWAP               uleb
 *
 * This means that the compilation process is a little more difficult, since
 * jumps (whose offsets need to be filled in later) don't know how big their
 * operand is.
 */

component Opcodes {
	def numOpcodes: int = 23;
	def map: Array<Opcode> = Array.new(numOpcodes); // XXX update this with the number of opcodes
}

def nothing() -> int {
	for (op in Opcode) {
		Opcodes.map[op.tag] = op;
	}
	return 1;
}
def nothing2 = nothing();

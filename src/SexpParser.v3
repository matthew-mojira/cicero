class SexpReader extends TextReader {
	private def sexps: Vector<Sexp> = Vector<Sexp>.new();
	private def stack: Stack<IncompleteSexp> = ArrayStack<IncompleteSexp>.new();
	private def buffer: StringBuilder = StringBuilder.new();
	private var startLine: int, startColumn: int;
	
	new(fileName: string) super(fileName, System.fileLoad(fileName)) {
		while (pos < limit) {
			match (char) {
				'(' => {
					if (buffer.length > 0) createAtom();
					stack.push(IncompleteSexp.new(fileName, line, column));
					advance1();
				}
				')' => {
					if (buffer.length > 0) createAtom();			
					if (stack.empty()) {
						fail("unmatched parentheses");
						return;
					}
					def complete = stack.pop().complete(line, column);
					if (stack.empty()) {
						sexps.put(complete);
					} else {
						stack.peek().subSexps.put(complete);
					}
					advance1();
				}
				'\"' => {
					// capture the entire string
					def a = Strings.parseLiteral(data, pos);
					def chars = a.0, str = a.1;
					if (chars < 0) {
						fail("malformed string literal");
						return;
					}

					// create string
					def new_str: Sexp = Sexp.new(
							SexpData.Token(Strings.format1("\"%s\"", str)),
							FileRange.new(fileName, line, column, posToLine(pos + chars), posToColumn(pos + chars)));
					addToEnclosing(new_str);

					advance(chars);
				}
				_ => if (isWhitespace(char)) {
					if (buffer.length > 0) createAtom();
					skipWhitespace();
				} else {
					def len = plus_rel(0, isAtomCharacter) - pos;
					if (len < 0) {
						fail("invalid character in identifier name");
						return;
					}

					def range = FileRange.new(fileName, line, column, posToLine(pos + len - 1), posToColumn(pos + len - 1));
					def str = readToken(len).image;

					def newSexp = Sexp.new(SexpData.Token(str), range);

					addToEnclosing(newSexp);
					/* whitespace rules allow something like
					 *   identifier"string"
					 * to be parsed as
					 *   identifier "string"
					 */
				}
			}
		}
		if (!stack.empty()) {
			fail("unmatched parentheses");
			return;
		}
	}

	private def createAtom() {
		// create atomic
		def new_atom: Sexp = Sexp.new(
			SexpData.Token(buffer.extract()),
			FileRange.new(fileName, startLine, startColumn, line, column));
		addToEnclosing(new_atom);
	}

	private def addToEnclosing(sexp: Sexp) {
		def enclosing: IncompleteSexp = stack.peek();
		if (enclosing == null) {
			// allow a non apply sexp to be at the top level
			sexps.put(sexp);
		} else {
			enclosing.subSexps.put(sexp);
		}
	}

	def getSexps() -> Array<Sexp> {
		if (!ok) return null;
		return sexps.extract();
	}
}

def isWhitespace(ch: byte) -> bool {
	return ch == ' ' || ch == '\t' || ch == '\n';
}

def isAtomCharacter(ch: byte) -> bool {
	match (ch) {
		' ' => return false;
		'\t' => return false;
		'\n' => return false;
		'\'' => return false;
		'\"' => return false;
		'(' => return false;
		')' => return false;
		'[' => return false;
		']' => return false;
		_ => return true;
	}
}

private class IncompleteSexp(fileName: string, beginLine: int, beginColumn: int) {
	def subSexps: Vector<Sexp> = Vector.new();

	def complete(endLine: int, endColumn: int) -> Sexp {
		return Sexp.new(SexpData.Apply(subSexps.extract()),
				FileRange.new(fileName, beginLine, beginColumn, endLine, endColumn));
	}
}

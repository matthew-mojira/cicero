class StrObject(str: string) extends Object {
	new () {
		if (CiceroOptions.sanityChecks) {
			if (str == null)
				System.error("string error", "null passed to constructor");
		}
	}

	def display() -> string { return Strings.format1("\"%s\"", str); }
	def isTrue()  -> bool   { return true; }

	/* METHODS */

	def s_concat(obj: Object) -> Result{
		if (obj.instanceOf(ClassObjects.classStr)){
			def str_value = (StrObject.!(obj).str);
			return Result.OK(StrObjects.fromString(Arrays.concat(this.str, str_value)));

		} else if (obj.instanceOf(ClassObjects.classChar)){
			def char_value = (CharObject.!(obj).char);
			return Result.OK(StrObjects.fromString(Arrays.concat(this.str, [char_value])));

		} else{
			return Result.Exn(ExnObjects.fromVirgil("+", "Invalid type for string concatenation"));
		}
	}

	def s_charAt(idx: IntObject) -> Result {
		def realIndex = idx.val.longValue();
		if (realIndex < 0 || realIndex >= str.length)
			return Result.Exn(ExnObjects.fromVirgil("str.char-at", outOfBounds(realIndex, str.length)));
		return Result.OK(CharObjects.fromByte(str[realIndex]));
	}

 	def s_length() -> Result {
		return Result.OK(IntObjects.fromLong(str.length));
	}
	def s_display() => Result.OK(StrObjects.fromString(display()));
}

def outOfBounds(len: long, idx: long) => Strings.format2("access at index %d is out of bounds for string of length %d", idx, len);

component StrObjects {
	/* canonical instances of strings */
	def strObjects: HashMap<string, StrObject> = Strings.newMap();
	// FIXME deprecated, rename everything to `fromString`
	def getStrObject(str: string) -> StrObject {
		return fromString(str);
	}
	def fromString(str: string) -> StrObject {
		if (CiceroOptions.sanityChecks) {
			if (str == null)
				System.error("string error", "null passed to fromString");
		}
		if (strObjects.has(str)) return strObjects[str];
		def newStr = StrObject.new(str);
		strObjects[str] = newStr;
		return newStr;
	}
}

// I don't believe it's possible to construct syntactically unreachable code,
// but removing it would be an optimization this implicitly performs.

def ignoreExceptions = false;

// XXX unused
enum EdgeType {
	UNCONDITIONAL, TRUE, FALSE, EXN
}

class CFGraph(bytecode: Bytecode) {
	def var head:    BasicBlock;
	def basicBlocks: Vector<BasicBlock> = Vector.new();

	new() {
		def bc = bytecode.instrs;
		def boundaries: Array<bool> = Array.new(bc.length + 4);
		def map: Array<int> = Array.new(bc.length + 4);
		def handlerStk: Stack<int> = ArrayStack.new();
		def handlerLoc: Array<int> = Array.new(bc.length + 4);
		if (bc.length > 0)
			boundaries[0] = true; // entry point
		if (!ignoreExceptions)
			handlerStk.push(bc.length); // no handler = exit function

		var pc = 0;
		while (pc < bc.length) {
			def ins = Ref<Instruction>.at(bc, pc);
			def opcode = ins.opcode;
			def operand = ins.operand;

			pc += 4;
			if (!ignoreExceptions) {
				match (opcode) {
					TRY   => handlerStk.push(pc + operand);
					CATCH => handlerStk.pop();
					_     => ;
				}
			}

			if (opcode.jump) {
				boundaries[pc + i24.view(operand)] = true;
				boundaries[pc] = true;
			}
			if (!ignoreExceptions && opcode.exception) {
				boundaries[handlerStk.peek()] = true; // XXX duplicate set many, many times
				handlerLoc[pc] = handlerStk.peek();
				boundaries[pc] = true;
			}
		}

		// Boundaries has the endpoints for basic blocks. Now to create
		// the basic block.
		var prev = 0;
		var num = 1;
		for (i = 4; i < bc.length; i += 4) {
			map[i] = num;
			if (boundaries[i]) {
				basicBlocks.put(BasicBlock.new(bc[prev ... i], prev));
				prev = i;
				num += 1;
			}
		}
		map[bc.length] = num;
		basicBlocks.put(BasicBlock.new(bc[prev ... bc.length], prev));
		basicBlocks.put(BasicBlock.new(null, bc.length));

		for (i < basicBlocks.length - 1) {
			def block = basicBlocks[i];
			def lastOp = Opcodes.map[block.bytes[block.bytes.length - 4]];
			def lastPc = block.startPc + block.bytes.length;
			
			if (lastOp.fallthrough)	{
				block.successors.add(basicBlocks[map[lastPc]]);
				basicBlocks[map[lastPc]].predecessors.add(block);
			}
			if (lastOp.jump) {
				def operand = (u24.!(block.bytes[block.bytes.length - 1]) << 16)
				            | (u24.!(block.bytes[block.bytes.length - 2]) << 8)
				            |  u24.!(block.bytes[block.bytes.length - 3]);
				def target = lastPc + i24.view(operand);
				block.successors.add(basicBlocks[map[target]]);
				basicBlocks[map[target]].predecessors.add(block);
			}
			if (!ignoreExceptions && lastOp.exception) {
				// get target from its mapping in handlerLoc
				def target = handlerLoc[lastPc];
				block.successors.add(basicBlocks[map[target]]);
				basicBlocks[map[target]].predecessors.add(block);
			}
		}
		head = basicBlocks[0];
	}

	def computeDominators() {
		// dominator of the start node is the start itself
		head.dominators.add(head);
		// for all other nodes, set all nodes as the dominators
		for (i < basicBlocks.length) {
			def block = basicBlocks[i];
			if (block == head) continue;

			block.dominators.addv(basicBlocks);
		}

		var domChanged = true;
		while (domChanged) {
			domChanged = false;

			for (i < basicBlocks.length) {
				def block = basicBlocks[i];
				if (block == head) continue;

				def predecessors = block.predecessors.toArray();
				if (predecessors.length == 0) continue;

				def newDoms: HashSet<BasicBlock> = predecessors[0].dominators.dup();
				for (i = 1; i < predecessors.length; i++) {
					def pred = predecessors[i];
					newDoms.retainAll(pred.dominators);
				}

				newDoms.add(block);				

				if (!newDoms.equalS(block.dominators)) {
					block.dominators = newDoms;
					domChanged = true;
				}
			}

		}
	}

	def computeImmediateDominator() {
		for (i < basicBlocks.length) {
			def block = basicBlocks[i];
			if (block == head){
				block.immDom = null;
				continue;
			}

			def strictDoms: HashSet<BasicBlock> = block.dominators.dup();
			strictDoms.delete(block);

			var immDomCand: BasicBlock;
			def arr = strictDoms.toArray();
			for (dom in arr) {
				var dominatedByOthers: bool;
				for (other in arr) {
					if (other != dom && other.dominators.contains(dom)) {
						dominatedByOthers = true;
						break;
					}
				}
				if (!dominatedByOthers) {
					immDomCand = dom;
					break;
				}
			}
			block.immDom = immDomCand;			
		}
	}

	def entryNodes() -> Array<BasicBlock> {
		 return Arrays.filter(basicBlocks.copy(), fun(bb: BasicBlock) => bb.predecessors.size() == 0);
	}

	def exitNodes() -> Array<BasicBlock> {
		 return Arrays.filter(basicBlocks.copy(), fun(bb: BasicBlock) => bb.successors.size() == 0);
	}

	def display() {
		System.puts("===\nBytecode:\n");
		System.puts(bytecode.display());
		System.ln();
		for (block in basicBlocks.copy()) {
			block.display();
		}		
	}
}

class BasicBlock(bytes: Range<byte>, startPc: int) {
	def successors:   HashSet<BasicBlock> = HashSet.new(BasicBlock.hash, BasicBlock.==);
	def predecessors: HashSet<BasicBlock> = HashSet.new(BasicBlock.hash, BasicBlock.==);
	var dominators:   HashSet<BasicBlock> = HashSet.new(BasicBlock.hash, BasicBlock.==);

	var immDom: BasicBlock;

	def hash() -> int {
		return startPc;
	}

	def display() {
		System.puts(Strings.format1("block at pc=%d ", startPc));
 		if (immDom != null) {
 			System.puts(Strings.format1("(=> imm dom: %d)\n", immDom.startPc));
 		} else {
 			System.puts("(=> imm dom: none)\n");
 		}
		
		def predecessors = predecessors.toArray();
		System.puts("   [");
		for (i = 0; i < predecessors.length - 1; i++) {
			System.puts(Strings.format1("%d, ", predecessors[i].startPc));
		}
		if (predecessors.length > 0)
			System.puts(Strings.format1("%d", predecessors[predecessors.length - 1].startPc));
		System.puts(Strings.format1("] -> %d ", startPc));
		def successors = successors.toArray();
		match (successors.length) {
			0 => System.puts("-> []\n");
			1 => System.puts(Strings.format1("-> [%d]\n", successors[0].startPc));
			2 => System.puts(Strings.format2("-> [%d, %d]\n", successors[0].startPc, successors[1].startPc));
			_ => System.error("branch error", "at least three targets in basic block");
		}
		def bc = Ranges.dup(bytes);
		var pc = 0;
		while (pc < bc.length) {
			def ins = Ref<Instruction>.at(bc, pc);
			def opcode = ins.opcode;
			def operand = ins.operand;

			System.puts(Strings.format3("  +%d: %s %d\n", startPc + pc, opcode.name, operand));
			pc += 4;
		}
	}
}

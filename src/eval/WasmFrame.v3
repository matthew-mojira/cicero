class WasmFrame extends FrameObject {

	new(prev: FrameObject, code: CodeObject, args: Array<(string, Object)>, nonlocalArgs: Array<(string, Object)>) super(prev, code, args) {
		if (code != null) {
			wasm = Code.Wasm.!(code.code).wasm;
			// XXX some slow unification here, which might lead to some nonlocals not being used from the args?
			nonlocals = Array.new(wasm.nonlocals.length);
			for (i < nonlocals.length) {
				def id = wasm.nonlocals[i];
				// search for id in nonlocal args
				var found: bool;
				for (p in nonlocalArgs) {
					if (Strings.equal(id, p.0)) {
						nonlocals[i] = p;
						found = true;
						break;
					}
				}
				if (!found) {
					// might this ever happen?
					System.error("eval error", "unable to unify nonlocal arguments");
				}
			}
		}
	}

	def var wasm: WasmBytecode;
	def var nonlocals: Array<(string, Object)>;

	def eval() {
		/* swap runtime components */
		def oldFrame      = WasmRuntime.frame;
		def oldStrings    = WasmRuntime.strings;
		def oldFuncholes  = WasmRuntime.funcholes;
		def oldClassholes = WasmRuntime.classholes;
		def oldObjects    = WasmRuntime.objects;
		def oldResult     = WasmRuntime.result;

		WasmRuntime.frame      = this;
		WasmRuntime.strings    = wasm.stringPool;
		WasmRuntime.funcholes  = wasm.funcPool;
		WasmRuntime.classholes = wasm.classPool;
		WasmRuntime.objects    = Vectors.ofN(wasm.constPool); // XXX could be destructive? but I don't think so
		WasmRuntime.result     = 0;

		var exn: bool;
		match (wasm.f) {
			Func0(f) => exn = f();
			Func1(f) => exn = f(args[0].1);
			Func2(f) => exn = f(args[0].1, args[1].1);
			Func3(f) => exn = f(args[0].1, args[1].1, args[2].1);
			Func4(f) => exn = f(args[0].1, args[1].1, args[2].1, args[3].1);
			Func5(f) => exn = f(args[0].1, args[1].1, args[2].1, args[3].1, args[4].1);
			Func6(f) => exn = f(args[0].1, args[1].1, args[2].1, args[3].1, args[4].1, args[5].1);
			Func7(f) => exn = f(args[0].1, args[1].1, args[2].1, args[3].1, args[4].1, args[5].1, args[6].1);
			Func8(f) => exn = f(args[0].1, args[1].1, args[2].1, args[3].1, args[4].1, args[5].1, args[6].1, args[7].1);
			Func9(f) => exn = f(args[0].1, args[1].1, args[2].1, args[3].1, args[4].1, args[5].1, args[6].1, args[7].1, args[8].1);
		}
		if (exn) {
			result = Result.Exn(ExnObject.!(WasmRuntime.objects[WasmRuntime.result]));
		} else {
			result = Result.OK(WasmRuntime.objects[WasmRuntime.result]);
		}

		/* unswap runtime components */
		WasmRuntime.frame      = oldFrame;
		WasmRuntime.strings    = oldStrings;
		WasmRuntime.funcholes  = oldFuncholes;
		WasmRuntime.classholes = oldClassholes;
		WasmRuntime.objects    = oldObjects;
		WasmRuntime.result     = oldResult;
	}

	def evalCode(code: CodeObject) -> Object {
		WasmRuntime.frame      = this;
		WasmRuntime.result     = 0;
		def wasm = Code.Wasm.!(code.code).wasm;
		WasmRuntime.strings    = wasm.stringPool;
		WasmRuntime.funcholes  = wasm.funcPool;
		WasmRuntime.classholes = wasm.classPool;
		WasmRuntime.objects    = Vectors.ofN(wasm.constPool); // XXX could be destructive? but I don't think so
		match (wasm.f) {
			Func0(f) => {
				def exn = f();
				if (exn) {
					result = Result.Exn(ExnObject.!(WasmRuntime.objects[WasmRuntime.result]));
				} else {
					result = Result.OK(WasmRuntime.objects[WasmRuntime.result]);
				}
				match (result) {
					OK(o) => return o;
					Exn(e) => return null;
					Uncomputed => {
						System.puts("evalCode in WasmFrame returned Uncomputed\n");
						System.error("internal error", "evalCode in WasmFrame returned Uncomputed\n");
					}
				}
			}
			_ => {
				// maybe should not happen?
				System.puts("unimplemented: WasmFrame.eval: FuncN (N != 0)\n");
				System.error("unimplemented", "WasmFrame.eval: FuncN (N != 0)");
			}
		}
		return null;
	}

	def getGlobal(id: string) -> Object {
		if (globals.has(id))
			return globals[id];
		return null;
	}

	def getNonlocal(id: string) -> Object { // FIXME don't use string
		for (p in nonlocals) {
			if (Strings.equal(p.0, id)) return p.1;
		}
		System.puts(Strings.format1("cannot find nonlocal %s\n", id));
		System.error("internal error", "cannot find nonlocal");
		return null;
	}

	def setGlobal(id: string, obj: Object) -> Object {
		return globals[id] = obj;
	}
}

class Eval {
	def globals: HashMap<string, Value> = Strings.newMap();
	private var frame: Frame;
	// not used?

	new() {
		// add builtins to environment
		for (builtin in Builtin.set.all) {
			globals[builtin.id] = Value.Builtin(builtin.func);
		}
		
		frame = Frame.new(this, [], []);
	}

	// FIXME refactor this approach
	def eval(exprs: Array<Expr>) -> Array<Value> {
		def vals: Vector<Value> = Vector<Value>.new();

		for (expr in exprs) {
			frame.evalFrame(expr);
			if (frame.exn) {
				System.error("eval error", frame.val.display());
			}
			vals.put(frame.val);
		}
		return vals.extract();
	}
}

// TODO abstract code into CodeObject a la cpython
class Frame {
	private var exec: Eval;
	def locals: HashMap<string, Value> = Strings.newMap();

	// you could replace this with a higher-tier evaluation function
	var evalFunc: Expr -> Value;

	// status flags as the result of evaluation
	var exn: bool = false;  // whether evaluation threw uncaught exception
	var val: Value;         // result of evaluation or exception value

	/* A frame may fail to initialize in the case of arity mismatch */
	new(exec: Eval, params: Array<string>, args: Array<Value>) {
		this.exec = exec;
		this.evalFunc = evalExpr;
		assertArity(params.length, args);
		if (!exn) {
			for (i < params.length) {
				locals[params[i]] = args[i];
			}
		}
	}

	// XXX not a good way of organizing things
	def evalFrame(code: Expr) {
		def v = evalFunc(code);
		if (!exn)
			val = v;
	}

	private def evalExpr(expr: Expr) -> Value {
		var value: Value;

		match (expr.data) {
			Lit(val) => value = val;
			Id(id) => {
				if (locals.has(id)) {
					value = locals[id];
				} else if (exec.globals.has(id)) {
					value = exec.globals[id];
				} else {
					throw(Value.Str(Strings.format1("unbound identifier: %s", id)));
				}
			}
			Apply(tgt, args) => {
				def tgtVal = evalExpr(tgt);
				// remember: these are recursive calls within `evalExpr` but
				// have nothing to do with evaluation frames in the language
				if (exn) return value;
				assertType(Type.Func, tgtVal);
				if (exn) return value;

				def argv: Array<Value> = Array.new(args.length);
				for (i < argv.length) {
					def arg = evalExpr(args[i]);
					if (exn) return value;
					argv[i] = arg;
				}

				// function call
				match (tgtVal) {
					Func(id, params, code) => {
						// create new frames here!
						def frame = Frame.new(exec, params, argv);
						// exception in creating frame happens only with arity mismatch
						if (frame.exn) {
							throw(frame.val);
							return value;
						}
						// eval frame
						frame.evalFrame(code);
						if (frame.exn) {
							throw(frame.val);
							return value;
						}
						value = frame.val;
						
					}
					Builtin(func) => {
						// function call
						def ret = func(argv);
						def val = ret.0, fnExn = ret.1;

						if (fnExn) {
							throw(val);
							return value;
						} else {
							value = val;
						}
						
					}
					_ => /* already typechecked, impossible case */;
				}
			}
			If(exprC, exprT, exprF) => {
				def cond = evalExpr(exprC);
				if (exn) return value;

				if (cond.isTrue()) {
					def v = evalExpr(exprT);
					if (exn) return value;
					value = v;
				} else {
					def v = evalExpr(exprF);
					if (exn) return value;
					value = v;
				}
			}
			Raise(expr) => {
				def v = evalExpr(expr);
				if (exn) return value;

				throw(v);
			}
			Catch(try, catch) => {
				def v = evalExpr(try);
				if (!exn) {
					value = v;
				} else {
					// catch exception
					exn = false;
					def e = evalExpr(catch);
					if (exn) return value;
					value = e;
				}
			}
			Func(id, params, body) => {
				def f = Value.Func(id, params, body);
				locals[id] = f;
				value = f;
			}
			Assign(id, expr) => {
				def v = evalExpr(expr);
				if (exn) return value;
				locals[id] = v;
				value = v;
			}
			Cond(cases) => {
				var sat = false;
				for (c in cases) {
					// case
					def cond = c.0, expr = c.1;

					// check cond
					def t = evalExpr(cond);
					if (exn) return value;
					if (t.isTrue()) {
						def v = evalExpr(expr);
						if (exn) return value;
						value = v;

						sat = true;
						break;
					}
				}

				if (!sat) {
					throw(Value.Str("cond error: no true branch"));
				}
			}
			While(cond, body) => {
				while (true) {
					def v = evalExpr(cond);
					if (exn) return value;

					if (!v.isTrue()) {
						value = v;
						break;
					}

					evalExpr(body);
					if (exn) return value;
				}
			}
			Begin(exprs) => {
				var last: Value;
				for (expr in exprs) {
					def v = evalExpr(expr);
					if (exn) return value;

					last = v;
				}
				value = last;
			}
		}

		return value;
	}
	
	/* throwing exceptions */

	// throw sets the exception value in the frame right away
	private def throw(value: Value) {
		exn = true;
		val = value;
	}

	private def assertType(exp: Type, val: Value) {
		if (exp != val.typeof())
			throw(Value.Str(Strings.format2("type mismatch: expected %s, got %s", exp.display(), val.typeof().display())));
	}

	private def assertArity(argc: int, vals: Range<Value>) {
		if (vals.length != argc)
			throw(Value.Str(Strings.format2("arity mismatch: expected %d, got %d", argc, vals.length)));
	}

}

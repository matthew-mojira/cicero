class OptionGroup(name: string, o: BasicOptions) {
	var list: List<(Opt, string, string)>;

	def newIntOption(name: string, defval: int, help: string) -> Option<int> {
		return add(o.newIntOption(name, defval), "=<int>", help);
	}
	def newBoolOption(name: string, defval: bool, help: string) -> Option<bool> {
		return add(o.newBoolOption(name, defval), "[=(true|false)]", help);
	}
	def newStringOption(name: string, defval: string, help: string) -> Option<string> {
		return add(o.newStringOption(name, defval), "=<string>", help);
	}
	def newPathOption(name: string, defval: string, help: string) -> Option<string> {
		return add(o.newStringOption(name, defval), "=<path>", help);
	}
	def newSizeOption(name: string, defval: u32, help: string) -> Option<u32> {
		return add(o.newSizeOption(name, defval), "=<int[K|M|G]>", help);
	}
	def newAddrOption(name: string, defval: u64, help: string) -> Option<u64> {
		return add(o.newAddrOption(name, defval), "=<address>", help);
	}
	def newEmptyOption(name: string, help: string) -> Option<bool> {
		return add(o.newOption(name, false, parseEmpty), "", help);
	}
	def newOption<T>(name: string, defval: T, typename: string, parseFun: string -> T, help: string) -> Option<T> {
		return add(o.newOption(name, defval, parseFun), typename, help);
	}
	def add<T>(opt: Option<T>, typename: string, help: string) -> Option<T> {
		list = List.new((opt, typename, help), list);
		return opt;
	}
	def parseEmpty(str: string) -> bool {
		return str == null;
	}

	def print(buf: StringBuilder) {
		buf.put1("%s OPTIONS\n\n", name);
		for (l = Lists.reverse(list); l != null; l = l.tail) {
			var t = l.head;
			buf.put2("    -%s%s\n", t.0.name, t.1);
			buf.put1("        %s\n", t.2);
		}
		buf.ln();
	}
}

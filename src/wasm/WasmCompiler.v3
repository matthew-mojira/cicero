def GET_GLOBAL: u32   = u32.view(CiWasmTarget.functionId(WasmFrame.getGlobal));
def GET_NONLOCAL: u32 = u32.view(CiWasmTarget.functionId(WasmFrame.getNonlocal));
def SET_GLOBAL: u32   = u32.view(CiWasmTarget.functionId(WasmFrame.setGlobal));
def GET_FIELD: u32    = u32.view(CiWasmTarget.functionId(Object.getField)); // null = failure
def SET_FIELD: u32    = u32.view(CiWasmTarget.functionId(Object.setFieldNull)); // false = failure

def LIST_FROM0: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from0));
def LIST_FROM1: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from1));
def LIST_FROM2: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from2));
def LIST_FROM3: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from3));
def LIST_FROM4: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from4));
def LIST_FROM5: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from5));
def LIST_FROM6: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from6));
def LIST_FROM7: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from7));
def LIST_FROM8: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from8));
def LIST_FROM9: u32 = u32.view(CiWasmTarget.functionId(ListObjects.from9));
def LIST_FROM10:u32 = u32.view(CiWasmTarget.functionId(ListObjects.from10));

def CALL_FUNC0: u32 = u32.view(CiWasmTarget.functionId(callFunc0));
def CALL_FUNC1: u32 = u32.view(CiWasmTarget.functionId(callFunc1));
def CALL_FUNC2: u32 = u32.view(CiWasmTarget.functionId(callFunc2));
def CALL_FUNC3: u32 = u32.view(CiWasmTarget.functionId(callFunc3));
def CALL_FUNC4: u32 = u32.view(CiWasmTarget.functionId(callFunc4));
def CALL_FUNC5: u32 = u32.view(CiWasmTarget.functionId(callFunc5));
def CALL_FUNC6: u32 = u32.view(CiWasmTarget.functionId(callFunc6));
def CALL_FUNC7: u32 = u32.view(CiWasmTarget.functionId(callFunc7));
def CALL_FUNC8: u32 = u32.view(CiWasmTarget.functionId(callFunc8));
def CALL_FUNC9: u32 = u32.view(CiWasmTarget.functionId(callFunc9));

def CREATE_FUNC0: u32 = u32.view(CiWasmTarget.functionId(createFunc0));
def CREATE_FUNC1: u32 = u32.view(CiWasmTarget.functionId(createFunc1));
def CREATE_FUNC2: u32 = u32.view(CiWasmTarget.functionId(createFunc2));
def CREATE_FUNC3: u32 = u32.view(CiWasmTarget.functionId(createFunc3));
def CREATE_FUNC4: u32 = u32.view(CiWasmTarget.functionId(createFunc4));
def CREATE_FUNC5: u32 = u32.view(CiWasmTarget.functionId(createFunc5));
def CREATE_FUNC6: u32 = u32.view(CiWasmTarget.functionId(createFunc6));
def CREATE_FUNC7: u32 = u32.view(CiWasmTarget.functionId(createFunc7));
def CREATE_FUNC8: u32 = u32.view(CiWasmTarget.functionId(createFunc8));
def CREATE_FUNC9: u32 = u32.view(CiWasmTarget.functionId(createFunc9));

def CREATE_CLASS: u32 = u32.view(CiWasmTarget.functionId(createClass));
def CREATE_OBJECT: u32 = u32.view(CiWasmTarget.functionId(createObject));

def TO_STRING: u32 = u32.view(CiWasmTarget.functionId(StrObject.str));

def RAISE_EXCEPTION: u32 = u32.view(CiWasmTarget.functionId(raiseException));
def TYPE_MISMATCH: u32 = u32.view(CiWasmTarget.functionId(Exceptions.typeMismatch));
def MISSING_FIELD: u32 = u32.view(CiWasmTarget.functionId(Exceptions.missingField));
def RETURN_OK:  u32 = u32.view(CiWasmTarget.functionId(returnOK));
def RETURN_EXN: u32 = u32.view(CiWasmTarget.functionId(returnExn));

def raiseException(msg: string) -> ExnObject {
	return ExnObjects.fromWasm(msg);
}

def isFunc(val: Object)  -> bool => val.instanceOf(ClassObjects.classFunc);
def isClass(val: Object) -> bool => val.instanceOf(ClassObjects.classClass);
def isString(val: Object)-> bool => val.instanceOf(ClassObjects.classStr);
def isTrue(o: Object)  -> bool => o.isTrue();
def isFalse(o: Object) -> bool => !o.isTrue();
def isNull(o: Object)  -> bool => o == null;
def isOK(r: Box<Result>) -> bool => Result.OK.?(r.data);
def isExn(r: Box<Result>) -> bool => Result.Exn.?(r.data);
def resultToObject(r: Box<Result>) -> Object {
	match (r.data) {
		OK(o) => return o;
		Exn(e) => return e;
		_ => {
			System.puts("resultToObject called on Uncomputed\n");
			System.error("internal error", "resultToObject called on Uncomputed\n");
			return null;
		}
	}
}

def IS_FUNC: u32  = u32.view(CiWasmTarget.functionId(isFunc));
def IS_CLASS: u32 = u32.view(CiWasmTarget.functionId(isClass));
def IS_STRING: u32= u32.view(CiWasmTarget.functionId(isString));
def IS_TRUE: u32  = u32.view(CiWasmTarget.functionId(isTrue));
def IS_FALSE: u32 = u32.view(CiWasmTarget.functionId(isFalse));
def IS_NULL: u32  = u32.view(CiWasmTarget.functionId(isNull));
def IS_OK: u32    = u32.view(CiWasmTarget.functionId(isOK));
def IS_EXN: u32   = u32.view(CiWasmTarget.functionId(isExn));
def RESULT_TO_OBJECT: u32  = u32.view(CiWasmTarget.functionId(resultToObject));
// XXX the copy versions are table indices which need to be called with call_indirect
// TODO: we can probably get rid of these since we are abusing the receiver as 
// scratch local0
var IS_FUNC_COPY:  int = -1; 
var IS_CLASS_COPY: int = -1;
var IS_STRING_COPY:int = -1;
var IS_TRUE_COPY:  int = -1; 
var IS_FALSE_COPY: int = -1;
var IS_NULL_COPY:  int = -1;
var COPY:          int = -1; 
var SWAP:          int = -1; 
var UNPACK_RESULT: int = -1; 

var COPY_SIG: i32 = -1;
var SWAP_SIG: i32 = -1;
var BLOCK_SIG: i32 = -1;

/* the callFuncN receives the function (already asserted) and arguments, and
 * needs to set up the call and get the return value
 * If the function is a method, it also sets up `self`
 */
def callFunc0(frame: FrameObject, func: FuncObject) => callFuncN(frame, func, []);
def callFunc1(frame: FrameObject, func: FuncObject, o0: Object) => callFuncN(frame, func, [o0]);
def callFunc2(frame: FrameObject, func: FuncObject, o0: Object, o1: Object) => callFuncN(frame, func, [o0, o1]);
def callFunc3(frame: FrameObject, func: FuncObject, o0: Object, o1: Object, o2: Object) => callFuncN(frame, func, [o0, o1, o2]);
def callFunc4(frame: FrameObject, func: FuncObject, o0: Object, o1: Object, o2: Object, o3: Object) => callFuncN(frame, func, [o0, o1, o2, o3]);
def callFunc5(frame: FrameObject, func: FuncObject, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object) => callFuncN(frame, func, [o0, o1, o2, o3, o4]);
def callFunc6(frame: FrameObject, func: FuncObject, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object, o5: Object) => callFuncN(frame, func, [o0, o1, o2, o3, o4, o5]);
def callFunc7(frame: FrameObject, func: FuncObject, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object, o5: Object, o6: Object) => callFuncN(frame, func, [o0, o1, o2, o3, o4, o5, o6]);
def callFunc8(frame: FrameObject, func: FuncObject, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object, o5: Object, o6: Object, o7: Object) => callFuncN(frame, func, [o0, o1, o2, o3, o4, o5, o6, o7]);
def callFunc9(frame: FrameObject, func: FuncObject, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object, o5: Object, o6: Object, o7: Object, o8: Object) => callFuncN(frame, func, [o0, o1, o2, o3, o4, o5, o6, o7, o8]);

def callFuncN(prev: FrameObject, fv: FuncObject, args: Array<Object>) -> Box<Result> {
	def params = fv.params, code = fv.code;

	// evaluate argument values
	var argv: Array<(string, Object)>;

	if (fv.instanceOf(ClassObjects.classMethod)) {
		argv = Array.new(args.length + 1);
		for (i < args.length) {
			def arg = args[i];
			if (i < params.length) // avoid out of bounds but don't raise exception
				argv[i + 1] = (params[i], arg);
		}
		argv[0] = ("self", MethodObject.!(fv).obj);
	} else {
		argv = Array.new(args.length);
		for (i < args.length) {
			def arg = args[i];
			if (i < params.length) // avoid out of bounds but don't raise exception
				argv[i] = (params[i], arg);
		}
	}

	if (args.length != params.length) {
		return Box.new(Result.Exn(ExnObjects.fromWasm(Exceptions.arityMismatch(params.length, args.length))));
	}

	// create new frame (and evaluate)
	def frame = prev.newFrame(fv.id, code, argv, fv.nonlocals);
	frame.eval();
	return Box.new(frame.result);
}

def createFunc0(funchole: Box<ASTData.Func>) => createFuncN(funchole.data, []);
def createFunc1(funchole: Box<ASTData.Func>, o0: Object) => createFuncN(funchole.data, [o0]);
def createFunc2(funchole: Box<ASTData.Func>, o0: Object, o1: Object) => createFuncN(funchole.data, [o0, o1]);
def createFunc3(funchole: Box<ASTData.Func>, o0: Object, o1: Object, o2: Object) => createFuncN(funchole.data, [o0, o1, o2]);
def createFunc4(funchole: Box<ASTData.Func>, o0: Object, o1: Object, o2: Object, o3: Object) => createFuncN(funchole.data, [o0, o1, o2, o3]);
def createFunc5(funchole: Box<ASTData.Func>, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object) => createFuncN(funchole.data, [o0, o1, o2, o3, o4]);
def createFunc6(funchole: Box<ASTData.Func>, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object, o5: Object) => createFuncN(funchole.data, [o0, o1, o2, o3, o4, o5]);
def createFunc7(funchole: Box<ASTData.Func>, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object, o5: Object, o6: Object) => createFuncN(funchole.data, [o0, o1, o2, o3, o4, o5, o6]);
def createFunc8(funchole: Box<ASTData.Func>, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object, o5: Object, o6: Object, o7: Object) => createFuncN(funchole.data, [o0, o1, o2, o3, o4, o5, o6, o7]);
def createFunc9(funchole: Box<ASTData.Func>, o0: Object, o1: Object, o2: Object, o3: Object, o4: Object, o5: Object, o6: Object, o7: Object, o8: Object) => createFuncN(funchole.data, [o0, o1, o2, o3, o4, o5, o6, o7, o8]);

def createFuncN(funchole: ASTData.Func, nonlocalArgs: Array<Object>) -> FuncObject {
	def nonlocals: Array<(string, Object)> = Array.new(funchole.nonlocals.length);

	var j = 0;
	def fn = FuncObjects.newFO(funchole.id, funchole.params, nonlocals, funchole.body);
	for (i < funchole.nonlocals.length) {
		// if the nonlocal is the function itself (for recursion)
		if (Strings.equal(funchole.nonlocals[i], funchole.id)) {
			nonlocals[i] = (funchole.id, fn);
		} else {
			nonlocals[i] = (funchole.nonlocals[i], nonlocalArgs[j++]);
		}
	}

	return fn;
}

def createObject(parentFr: FrameObject, clsObj: ClassObject) -> Box<Result> {
	def obj = Objects.newObject(clsObj);

	def classes: Vector<ClassObject> = Vector.new();
	for (cls = clsObj; cls != null; cls = cls.superclass)
		classes.put(cls);

	// initialization order is from base class downwards, which
	// may involve reinitializing some fields
	for (cls in classes.reverse().extract()) {
		// initialize fields
		for (field in cls.classFields) {
			def name = field.0, expr = field.1;

			// XXX hackfix
			if (expr == null) continue;
			// create new frames here!
			def frame = parentFr.newFrame(Strings.format2("%s.%s", cls.name, name), expr, [], []);
			frame.eval();
			if (frame.isExn()) {
				return Box.new(frame.result);
			}
			obj.setField(name, frame.getValue());
		}
		// call initializer
		if (cls.init != null) {
			def args = [("self", obj)];
			def code = cls.init;

			// create new frames here!
			def frame = parentFr.newFrame(Strings.format1("%s.init", cls.name), code, args, []);
			frame.eval();
			if (frame.isExn()) {
				return Box.new(frame.result);
			}
		} 
	}
	return Box.new(Result.OK(obj));
}

def createClass(o: Object, box: Box<ClassObject -> ClassObject>) -> Box<Result> {
	if (!o.instanceOf(ClassObjects.classClass)) {
		return Box.new(Result.Exn(ExnObjects.fromWasm(Exceptions.typeMismatch(ClassObjects.classClass, o))));
	}

	def superclass = ClassObject.!(o);
	def classhole = box.data;
	return Box.new(Result.OK(classhole(superclass)));
}

def returnOK(o: Object) -> Box<Result> => Box.new(Result.OK(o));
def returnExn(e: ExnObject) -> Box<Result> => Box.new(Result.Exn(e));

class WasmCompiler {
	// TODO need extra information about parameters and locals
	// TODO get better wasm code generator (use Aeneas?)
	def wasm: DataWriter = DataWriter.new();
	def params: Array<string>;

	new(ast: AST, params) {
		// Initialize some deferred elements
		if (BLOCK_SIG < 0) {
			BLOCK_SIG = CiWasmTarget.functionTypeId<Object, Object>();
			COPY_SIG  = CiWasmTarget.functionTypeId<Object, (Object, Object)>();
			SWAP_SIG  = CiWasmTarget.functionTypeId<(Object, Object), (Object, Object)>();

			def isTrueCopy: DataWriter = DataWriter.new();
			isTrueCopy.puta([0x00, 0x20, 0x00, 0x20, 0x00, 0x10]);
			isTrueCopy.put_uleb32(IS_TRUE);
			isTrueCopy.puta([0x0B]);
			def isFalseCopy: DataWriter = DataWriter.new();
			isFalseCopy.puta([0x00, 0x20, 0x00, 0x20, 0x00, 0x10]);
			isFalseCopy.put_uleb32(IS_FALSE);
			isFalseCopy.puta([0x0B]);
			def isFuncCopy: DataWriter = DataWriter.new();
			isFuncCopy.puta([0x00, 0x20, 0x00, 0x20, 0x00, 0x10]);
			isFuncCopy.put_uleb32(IS_FUNC);
			isFuncCopy.puta([0x0B]);
			def isClassCopy: DataWriter = DataWriter.new();
			isClassCopy.puta([0x00, 0x20, 0x00, 0x20, 0x00, 0x10]);
			isClassCopy.put_uleb32(IS_CLASS);
			isClassCopy.puta([0x0B]);
			def isStringCopy: DataWriter = DataWriter.new();
			isStringCopy.puta([0x00, 0x20, 0x00, 0x20, 0x00, 0x10]);
			isStringCopy.put_uleb32(IS_STRING);
			isStringCopy.puta([0x0B]);
			def isNullCopy: DataWriter = DataWriter.new();
			isNullCopy.puta([0x00, 0x20, 0x00, 0x20, 0x00, 0x10]);
			isNullCopy.put_uleb32(IS_NULL);
			isNullCopy.puta([0x0B]);
			def unpackResult: DataWriter = DataWriter.new();
			unpackResult.puta([0x00, 0x20, 0x00, 0x10]);
			unpackResult.put_uleb32(RESULT_TO_OBJECT);
			unpackResult.puta([0x20, 0x00, 0x10]);
			unpackResult.put_uleb32(IS_EXN);
			unpackResult.puta([0x0B]);
			def isFuncCode:  Array<byte> = isFuncCopy.extract();
			def isClassCode: Array<byte> = isClassCopy.extract();
			def isStringCode: Array<byte>= isStringCopy.extract();
			def isTrueCode:  Array<byte> = isTrueCopy.extract();
			def isFalseCode: Array<byte> = isFalseCopy.extract();
			def isNullCode:  Array<byte> = isNullCopy.extract();
			def unpackResultCode: Array<byte> = unpackResult.extract();
			def copy: Array<byte> = [0x00, 0x20, 0x00, 0x20, 0x00, 0x0B];
			def swap: Array<byte> = [0x00, 0x20, 0x01, 0x20, 0x00, 0x0B];

			IS_FUNC_COPY  = wave.new_func(COPY_SIG, Pointer.atContents(isFuncCode), isFuncCode.length);
			IS_CLASS_COPY = wave.new_func(COPY_SIG, Pointer.atContents(isClassCode), isClassCode.length);
			IS_STRING_COPY= wave.new_func(COPY_SIG, Pointer.atContents(isStringCode), isStringCode.length);
			IS_TRUE_COPY  = wave.new_func(COPY_SIG, Pointer.atContents(isTrueCode), isTrueCode.length);
			IS_FALSE_COPY = wave.new_func(COPY_SIG, Pointer.atContents(isFalseCode), isFalseCode.length);
			IS_NULL_COPY  = wave.new_func(COPY_SIG, Pointer.atContents(isNullCode), isFalseCode.length);
			UNPACK_RESULT = wave.new_func(COPY_SIG, Pointer.atContents(unpackResultCode), unpackResultCode.length);
			COPY = wave.new_func(COPY_SIG, Pointer.atContents(copy), copy.length);
			SWAP = wave.new_func(SWAP_SIG, Pointer.atContents(swap), swap.length);
		}

		addLocal("<receiver>");
		// XXX I don't know what this receiver local (parameter) is or why virgil compiler adds it.
		// It is useful in some instances as a scratch local to rearrange the value stack.
		// so we're using it for that. Hopefully its true value is not necessary (not used anywhere thus far).
		addLocal("<frame>");    // frame is made available for whenever it's needed
		Arrays.map(params, addLocal); // XXX different behavior on duplicated locals? or parser should forbid?
		wasm.put_uleb32(1); // 1 set of
		wasm.put_uleb32(10);// 10 of
		// TODO fill hole with locals.length
		wasm.putb(0x7F);    // i32

		// FUNCTION BODY
		wasm.putb(WasmOp.BLOCK.opcode);
		wasm.putb(0x7F);    // (result i32)
		blockDepth++;
			handlerStack.push(blockDepth);

			compileAST(ast);
			
			wasm.putb(WasmOp.CALL.opcode);
			wasm.put_uleb32(RETURN_OK);
			wasm.putb(WasmOp.RETURN.opcode); 
			wasm.putb(WasmOp.UNREACHABLE.opcode); 

			handlerStack.pop(); // XXX unnecessary
		wasm.putb(WasmOp.END.opcode);
		blockDepth--;

		wasm.putb(WasmOp.CALL.opcode);
		wasm.put_uleb32(RETURN_EXN);

		wasm.putb(WasmOp.END.opcode);
	}

	// from BytecodeCompiler
	def locals:    Vector<string> = Vector.new();
	def nonlocals: Vector<string> = Vector.new();

	def handlerStack: Stack<int> = ArrayStack.new();
	var blockDepth = 0;

	def compile() -> WasmFunction {
		/* TODO We will have to figure out all the locals that will be in the function. 
		 * Some of them are locals because they are parameters. Like the BytecodeCompiler
		 * there should be an argument for these locals, which end up getting handled in
		 * the same way as Wasm arguments (they become the first locals). 
		 *
		 * From running the compile process `locals` will have the full set of locals
		 * and the map from indices to names. However, this also includes the parameters,
		 * so we will have to take a slice after the parameters, so we only have bona-fide
		 * locals to work with.
		 *
		 * Those bona-fide locals will be emitted as part of the code's locals declaration.
		 */
		// System.puts("Extracting the bytecode that was created!\n");
		def wasm = wasm.extract();
		// dump bytes
		// System.putc('\n');
		// for (b in wasm) {
		// 	System.puts(Strings.format1("%x", b));
		// }
		// System.putc('\n');

		var sig: int;
		match (params.length) {
			0 => sig = CiWasmTarget.functionTypeId<(int, Object), Box<Result>>();
			1 => sig = CiWasmTarget.functionTypeId<(int, Object, Object), Box<Result>>();
			2 => sig = CiWasmTarget.functionTypeId<(int, Object, Object, Object), Box<Result>>();
			3 => sig = CiWasmTarget.functionTypeId<(int, Object, Object, Object, Object), Box<Result>>();
			4 => sig = CiWasmTarget.functionTypeId<(int, Object, Object, Object, Object, Object), Box<Result>>();
			5 => sig = CiWasmTarget.functionTypeId<(int, Object, Object, Object, Object, Object, Object), Box<Result>>();
			6 => sig = CiWasmTarget.functionTypeId<(int, Object, Object, Object, Object, Object, Object, Object), Box<Result>>();
			7 => sig = CiWasmTarget.functionTypeId<(int, Object, Object, Object, Object, Object, Object, Object, Object), Box<Result>>();
			8 => sig = CiWasmTarget.functionTypeId<(int, Object, Object, Object, Object, Object, Object, Object, Object, Object), Box<Result>>();
			9 => sig = CiWasmTarget.functionTypeId<(int, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object), Box<Result>>();
			_ => {
				System.puts("params unknown\n");
				System.error("compile error", "params unknown");
			}
		}
		def fid  = wave.new_func(sig, Pointer.atContents(wasm), wasm.length);
		if (fid < 0) {
			System.puts("failed validation, terminating\n");
			System.error("failed validation", "generated function failed validation");
		}
		var func: WasmFunction = WasmFunction.Func0(fun (f: FrameObject) => Box.new(Result.Uncomputed));
		match (params.length) {
			0 => func = WasmFunction.Func0(CiRuntime.forgeClosure<void, FrameObject, Box<Result>>(Pointer.NULL + fid, void));	
			1 => func = WasmFunction.Func1(CiRuntime.forgeClosure<void, (FrameObject, Object), Box<Result>>(Pointer.NULL + fid, void));
			2 => func = WasmFunction.Func2(CiRuntime.forgeClosure<void, (FrameObject, Object, Object), Box<Result>>(Pointer.NULL + fid, void));
			3 => func = WasmFunction.Func3(CiRuntime.forgeClosure<void, (FrameObject, Object, Object, Object), Box<Result>>(Pointer.NULL + fid, void));
			4 => func = WasmFunction.Func4(CiRuntime.forgeClosure<void, (FrameObject, Object, Object, Object, Object), Box<Result>>(Pointer.NULL + fid, void));
			5 => func = WasmFunction.Func5(CiRuntime.forgeClosure<void, (FrameObject, Object, Object, Object, Object, Object), Box<Result>>(Pointer.NULL + fid, void));
			6 => func = WasmFunction.Func6(CiRuntime.forgeClosure<void, (FrameObject, Object, Object, Object, Object, Object, Object), Box<Result>>(Pointer.NULL + fid, void));
			7 => func = WasmFunction.Func7(CiRuntime.forgeClosure<void, (FrameObject, Object, Object, Object, Object, Object, Object, Object), Box<Result>>(Pointer.NULL + fid, void));
			8 => func = WasmFunction.Func8(CiRuntime.forgeClosure<void, (FrameObject, Object, Object, Object, Object, Object, Object, Object, Object), Box<Result>>(Pointer.NULL + fid, void));
			9 => func = WasmFunction.Func9(CiRuntime.forgeClosure<void, (FrameObject, Object, Object, Object, Object, Object, Object, Object, Object, Object), Box<Result>>(Pointer.NULL + fid, void));
		}
		return func;
	}
	
	def compileAST(expr: AST) {
		match (expr.data) {
			Lit(lit) => {
				// TODO disable GC and implement non-moving collector, or target wasm GC
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(ptrAt(lit));
			}
  			VarGet(id, mode) => match (mode.data) {
  				Local    => {
 					wasm.putb(WasmOp.GET_LOCAL.opcode);
 					wasm.put_uleb32(addLocal(id));

					// null check
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(IS_NULL_COPY);
					wasm.putb(WasmOp.CALL_INDIRECT.opcode);
					wasm.putb(COPY_SIG);
					wasm.putb(0x00);

					// throw exception if null
					wasm.putb(WasmOp.IF.opcode);
					wasm.put_sleb32(BLOCK_SIG);
					blockDepth++;
						wasm.putb(WasmOp.I32_CONST.opcode);
						wasm.put_sleb32(ptrAt(ExnObjects.fromWasm(Exceptions.unboundLocal(id))));
						wasm.putb(WasmOp.BR.opcode);
						wasm.put_sleb32(blockDepth - handlerStack.peek());
					wasm.putb(WasmOp.END.opcode);
					blockDepth--;

 				}
  				Global => {
					wasm.putb(WasmOp.GET_LOCAL.opcode);
					wasm.putb(1 /* frame */);
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(ptrAtStr(id)); // string
 					wasm.putb(WasmOp.CALL.opcode);
 					wasm.put_uleb32(GET_GLOBAL);

					// null check
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(IS_NULL_COPY);
					wasm.putb(WasmOp.CALL_INDIRECT.opcode);
					wasm.putb(COPY_SIG);
					wasm.putb(0x00);

					// throw exception if null
					wasm.putb(WasmOp.IF.opcode);
					wasm.put_sleb32(BLOCK_SIG);
					blockDepth++;
						wasm.putb(WasmOp.I32_CONST.opcode);
						wasm.put_sleb32(ptrAt(ExnObjects.fromWasm(Exceptions.unboundGlobal(id))));
						wasm.putb(WasmOp.BR.opcode);
						wasm.put_sleb32(blockDepth - handlerStack.peek());
					wasm.putb(WasmOp.END.opcode);
					blockDepth--;
				}
  				Nonlocal => {
					wasm.putb(WasmOp.GET_LOCAL.opcode);
					wasm.putb(1 /* frame */);
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(ptrAtStr(id));
 					wasm.putb(WasmOp.CALL.opcode);
 					wasm.put_uleb32(GET_NONLOCAL);
					// could emit a null check if using sanity checks
				}
			}
 			VarSet(id, mode, val) => match (mode.data) {
 				Local => {
					compileAST(val);
 					wasm.putb(WasmOp.TEE_LOCAL.opcode);
 					wasm.put_uleb32(addLocal(id));
 				}
 				Global => {
					wasm.putb(WasmOp.GET_LOCAL.opcode);
					wasm.putb(1 /* frame */);
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(ptrAtStr(id));
					compileAST(val);
 					wasm.putb(WasmOp.CALL.opcode);
 					wasm.put_uleb32(SET_GLOBAL);
				}
 				Nonlocal => System.error("compile error", "illegal case on varset: Nonlocal");
 			}
 			And(left, right) => {
 				compileAST(left);

				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(IS_TRUE_COPY);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);

				wasm.putb(WasmOp.IF.opcode);
				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					wasm.putb(WasmOp.DROP.opcode);
					compileAST(right);
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;
 			}
 			Or(left, right) => {
 				compileAST(left);

				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(IS_FALSE_COPY);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);

 				wasm.putb(WasmOp.IF.opcode);
 				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					wasm.putb(WasmOp.DROP.opcode);
					compileAST(right);
 				wasm.putb(WasmOp.END.opcode);
				blockDepth--;
 			}
 			Apply(tgt, args) => {
				wasm.putb(WasmOp.GET_LOCAL.opcode);
				wasm.putb(1 /* frame */);
				compileAST(tgt);

				// assert func
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(IS_FUNC_COPY);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);

				// throw exception if not func
				wasm.putb(WasmOp.IF.opcode);
				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					// skip
				wasm.putb(WasmOp.ELSE.opcode);
					// top of stack is problematic object
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(ptrAt(ClassObjects.classFunc));

					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(SWAP);
					wasm.putb(WasmOp.CALL_INDIRECT.opcode);
					wasm.putb(SWAP_SIG);
					wasm.putb(0x00);

					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(TYPE_MISMATCH);
					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(RAISE_EXCEPTION);
					wasm.putb(WasmOp.BR.opcode);
					wasm.put_sleb32(blockDepth - handlerStack.peek());
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;

				for (arg in args)
					compileAST(arg);
				// dispatch on number of args to variadic function
				wasm.putb(WasmOp.CALL.opcode);
				match (args.length) {
					0 => wasm.put_uleb32(CALL_FUNC0);
					1 => wasm.put_uleb32(CALL_FUNC1);
					2 => wasm.put_uleb32(CALL_FUNC2);
					3 => wasm.put_uleb32(CALL_FUNC3);
					4 => wasm.put_uleb32(CALL_FUNC4);
					5 => wasm.put_uleb32(CALL_FUNC5);
					6 => wasm.put_uleb32(CALL_FUNC6);
					7 => wasm.put_uleb32(CALL_FUNC7);
					8 => wasm.put_uleb32(CALL_FUNC8);
					9 => wasm.put_uleb32(CALL_FUNC9);
					_ => {
						System.puts(Strings.format1("Translating too many arguments: %d\n", args.length));
						System.error("compile error", "translating too many arguments");
					}
				}

				// unpack result
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(UNPACK_RESULT);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);

				// if exception, find handler
				wasm.putb(WasmOp.IF.opcode);
				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					wasm.putb(WasmOp.BR.opcode);
					wasm.put_sleb32(blockDepth - handlerStack.peek());
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;

			}
 			If(cond, left, right) => {
				compileAST(cond);
				wasm.putb(WasmOp.CALL.opcode);
				wasm.put_uleb32(IS_TRUE);
 				wasm.putb(WasmOp.IF.opcode);
 				wasm.putb(0x7F); // result i32
				blockDepth++;
					compileAST(left);
				wasm.putb(WasmOp.ELSE.opcode);
					compileAST(right);
 				wasm.putb(WasmOp.END.opcode);
				blockDepth--;
			}
			Cond(cases) => {
				wasm.putb(WasmOp.BLOCK.opcode);
				wasm.putb(0x7F);
				blockDepth++;
				for (c in cases) {
					def cond = c.0;
					def body = c.1;
					wasm.putb(WasmOp.BLOCK.opcode);
					wasm.putb(0x7F);
					blockDepth++;
					compileAST(cond);
					
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(IS_FALSE_COPY);
					wasm.putb(WasmOp.CALL_INDIRECT.opcode);
					wasm.putb(COPY_SIG);
					wasm.putb(0x00);

					wasm.putb(WasmOp.BR_IF.opcode);
					wasm.put_uleb32(0); // next case
					compileAST(body);
					wasm.putb(WasmOp.BR.opcode);
					wasm.put_uleb32(1); // done
					wasm.putb(WasmOp.END.opcode);
					blockDepth--;
				}

				// throw exception
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(ptrAt(ExnObjects.fromWasm(Exceptions.noTrueBranch)));
				wasm.putb(WasmOp.BR.opcode);
				wasm.put_sleb32(blockDepth - handlerStack.peek());

				wasm.putb(WasmOp.END.opcode);
				blockDepth--;
			}
			Raise(exn) => {
				compileAST(exn);

				// assert string
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(IS_STRING_COPY);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);

				// throw exception if not string
				wasm.putb(WasmOp.IF.opcode);
				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					// skip
				wasm.putb(WasmOp.ELSE.opcode);
					// top of stack is problematic object
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(ptrAt(ClassObjects.classStr));

					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(SWAP);
					wasm.putb(WasmOp.CALL_INDIRECT.opcode);
					wasm.putb(SWAP_SIG);
					wasm.putb(0x00);

					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(TYPE_MISMATCH);
					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(RAISE_EXCEPTION);
					wasm.putb(WasmOp.BR.opcode);
					wasm.put_sleb32(blockDepth - handlerStack.peek());
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;

				wasm.putb(WasmOp.CALL.opcode);
				wasm.put_uleb32(TO_STRING);
				wasm.putb(WasmOp.CALL.opcode);
				wasm.put_uleb32(RAISE_EXCEPTION);
				wasm.putb(WasmOp.BR.opcode);
				wasm.put_sleb32(blockDepth - handlerStack.peek());
			}
 			Catch(try, id, mode, catch) => {
					wasm.putb(WasmOp.BLOCK.opcode);
					wasm.putb(0x7F);
					blockDepth++;
						wasm.putb(WasmOp.BLOCK.opcode);
						wasm.putb(0x7F);
						blockDepth++;

						handlerStack.push(blockDepth);

						compileAST(try);
						wasm.putb(WasmOp.BR.opcode);
						wasm.put_uleb32(1); // ok

						handlerStack.pop();

						wasm.putb(WasmOp.END.opcode);
						blockDepth--;

					match (mode.data) {
						Local => {
							wasm.putb(WasmOp.TEE_LOCAL.opcode);
							wasm.put_uleb32(addLocal(id));
						}
						Global => {
							wasm.putb(WasmOp.SET_LOCAL.opcode);
							wasm.putb(0 /* XXX: what is this? scratch */);
							wasm.putb(WasmOp.GET_LOCAL.opcode);
							wasm.putb(1 /* frame */);
							wasm.putb(WasmOp.I32_CONST.opcode);
							wasm.put_sleb32(ptrAtStr(id)); // string
							wasm.putb(WasmOp.GET_LOCAL.opcode);
							wasm.putb(0 /* XXX: what is this? scratch */);
							// TODO value here
							wasm.putb(WasmOp.CALL.opcode);
							wasm.put_uleb32(SET_GLOBAL);
						}
						Nonlocal => System.error("compile error", "illegal case on catch: Nonlocal");
					}
					wasm.putb(WasmOp.DROP.opcode); // XXX this is unoptimal. Don't TEE on local and create a void-returning global.get
					// TODO put assignment of value to mode
					compileAST(catch);

					wasm.putb(WasmOp.END.opcode);
					blockDepth--;
			}
			Func(id, params, body, nonlocals) => {
 				body.compile(params);

				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(ptrAtBox(Box.new(ASTData.Func.!(expr.data))));	// XXX boxing
 			
				var nonlocalCount = 0;
 				for (i < nonlocals.length) {
 					def nonlocal = nonlocals[i];
 					if (Strings.equal(nonlocal, id))
 						// the function itself is captured, but not loaded to a local
 						continue;
 					// this variable will be captured!
 					wasm.putb(WasmOp.GET_LOCAL.opcode);
 					wasm.put_uleb32(addLocal(nonlocal)); // XXX can this be null? (unbound local)
					nonlocalCount++;
 				}
				//System.puts(Strings.format1("nonlocal count: %d\n", nonlocalCount));
 				wasm.putb(WasmOp.CALL.opcode);
				match (nonlocalCount) {
					0 => wasm.put_uleb32(CREATE_FUNC0);
					1 => wasm.put_uleb32(CREATE_FUNC1);
					2 => wasm.put_uleb32(CREATE_FUNC2);
					3 => wasm.put_uleb32(CREATE_FUNC3);
					4 => wasm.put_uleb32(CREATE_FUNC4);
					5 => wasm.put_uleb32(CREATE_FUNC5);
					6 => wasm.put_uleb32(CREATE_FUNC6);
					7 => wasm.put_uleb32(CREATE_FUNC7);
					8 => wasm.put_uleb32(CREATE_FUNC8);
					9 => wasm.put_uleb32(CREATE_FUNC9);
					_ => {
						System.puts(Strings.format1("Translating too many nonlocals: %d\n", nonlocalCount));
						System.error("compile error", "translating too many nonlocals");
					}
				}
 			}
 			While(cond, body) => {
				wasm.putb(WasmOp.BLOCK.opcode);
				wasm.putb(0x7F);
				blockDepth++;
					wasm.putb(WasmOp.LOOP.opcode);
					wasm.putb(0x7F); // is this needed?
					blockDepth++;
						compileAST(cond);
						wasm.putb(WasmOp.I32_CONST.opcode);
						wasm.put_sleb32(IS_FALSE_COPY);
						wasm.putb(WasmOp.CALL_INDIRECT.opcode);
						wasm.putb(COPY_SIG);
						wasm.putb(0x00);
						wasm.putb(WasmOp.BR_IF.opcode);
						wasm.put_uleb32(1); // exit loop

						compileAST(body);
						wasm.putb(WasmOp.BR.opcode);
						wasm.put_uleb32(0); // back to top of loop

					wasm.putb(WasmOp.END.opcode);
					blockDepth--;
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;
			}
 			Begin(exprs) => {
				for (i < exprs.length - 1) {
					compileAST(exprs[i]);
 					wasm.putb(WasmOp.DROP.opcode);
				}
				compileAST(exprs[exprs.length - 1]);
				
			}
 			GetField(field, obj) => {
				compileAST(obj);
				
				// XXX store object in local0
				wasm.putb(WasmOp.TEE_LOCAL.opcode);
				wasm.putb(0 /*scratch*/);

				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(ptrAtStr(field));
				wasm.putb(WasmOp.CALL.opcode);
				wasm.put_uleb32(GET_FIELD); // null on failure

				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(IS_NULL_COPY);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);
				// check failure condition
				wasm.putb(WasmOp.IF.opcode);
				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					wasm.putb(WasmOp.DROP.opcode);

					wasm.putb(WasmOp.GET_LOCAL.opcode); // XXX local0
					wasm.putb(0 /*scratch*/);
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(ptrAtStr(field));

					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(MISSING_FIELD);
					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(RAISE_EXCEPTION);
					
					wasm.putb(WasmOp.BR.opcode);
					wasm.put_sleb32(blockDepth - handlerStack.peek());
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;
			}
 			SetField(field, obj, val) => {
				compileAST(obj);
				wasm.putb(WasmOp.TEE_LOCAL.opcode);
				wasm.putb(0 /* XXX */);
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(ptrAtStr(field));
				compileAST(val);
				wasm.putb(WasmOp.CALL.opcode);
				wasm.put_uleb32(SET_FIELD); // null on failure
				
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(IS_NULL_COPY);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);
				// check failure condition
				wasm.putb(WasmOp.IF.opcode);
				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					wasm.putb(WasmOp.DROP.opcode);

					wasm.putb(WasmOp.GET_LOCAL.opcode); // XXX local0
					wasm.putb(0 /*scratch*/);
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(ptrAtStr(field));

					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(MISSING_FIELD);
					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(RAISE_EXCEPTION);
					
					wasm.putb(WasmOp.BR.opcode);
					wasm.put_sleb32(blockDepth - handlerStack.peek());
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;
			}
 			Class(id, superclass, init, fields, methods) => {
				// there are subcodes which are getting compiled here
				match (superclass) {
					Nothing => {
						wasm.putb(WasmOp.I32_CONST.opcode);
						wasm.put_sleb32(ptrAt(ClassObjects.classBase));
					}
					Just(expr) => compileAST(expr);
				}
				var init2: CodeObject;
				match (init) {
					Nothing => ;
					Just(code) => {
						code.compile(["self"]);
						init2 = code;
					}
				}
				for (field in fields) field.1.compile([]);
				def classhole = ClassObjects.classhole(id, init2, fields, Arrays.map(methods, funcToFunc));

				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(ptrAtBox(Box.new(classhole))); // XXX this is garbage

				wasm.putb(WasmOp.CALL.opcode);
				wasm.put_uleb32(CREATE_CLASS);

				// unpack result
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(UNPACK_RESULT);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);

				// if exception, find handler
				wasm.putb(WasmOp.IF.opcode);
				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					wasm.putb(WasmOp.BR.opcode);
					wasm.put_sleb32(blockDepth - handlerStack.peek());
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;
			}
 			New(expr) => {
 				wasm.putb(WasmOp.GET_LOCAL.opcode);
 				wasm.putb(1 /* frame */);
 				compileAST(expr);
				
				// assert class
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(IS_CLASS_COPY);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);

				// throw exception if not class
				wasm.putb(WasmOp.IF.opcode);
				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					// skip
				wasm.putb(WasmOp.ELSE.opcode);
					// top of stack is problematic object
					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(ptrAt(ClassObjects.classStr));

					wasm.putb(WasmOp.I32_CONST.opcode);
					wasm.put_sleb32(SWAP);
					wasm.putb(WasmOp.CALL_INDIRECT.opcode);
					wasm.putb(SWAP_SIG);
					wasm.putb(0x00);

					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(TYPE_MISMATCH);
					wasm.putb(WasmOp.CALL.opcode);
					wasm.put_uleb32(RAISE_EXCEPTION);
					wasm.putb(WasmOp.BR.opcode);
					wasm.put_sleb32(blockDepth - handlerStack.peek());
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;

 				wasm.putb(WasmOp.CALL.opcode);
 				wasm.put_uleb32(CREATE_OBJECT);

				// unpack result
				wasm.putb(WasmOp.I32_CONST.opcode);
				wasm.put_sleb32(UNPACK_RESULT);
				wasm.putb(WasmOp.CALL_INDIRECT.opcode);
				wasm.putb(COPY_SIG);
				wasm.putb(0x00);

				// if exception, find handler
				wasm.putb(WasmOp.IF.opcode);
				wasm.put_sleb32(BLOCK_SIG);
				blockDepth++;
					wasm.putb(WasmOp.BR.opcode);
					wasm.put_sleb32(blockDepth - handlerStack.peek());
				wasm.putb(WasmOp.END.opcode);
				blockDepth--;
			}
 			List(elems) => {
				for (elem in elems)
					compileAST(elem);
				// dispatch on size of list to variadic function
				wasm.putb(WasmOp.CALL.opcode);
				match (elems.length) {
					0 => wasm.put_uleb32(LIST_FROM0);
					1 => wasm.put_uleb32(LIST_FROM1);
					2 => wasm.put_uleb32(LIST_FROM2);
					3 => wasm.put_uleb32(LIST_FROM3);
					4 => wasm.put_uleb32(LIST_FROM4);
					5 => wasm.put_uleb32(LIST_FROM5);
					6 => wasm.put_uleb32(LIST_FROM6);
					7 => wasm.put_uleb32(LIST_FROM7);
					8 => wasm.put_uleb32(LIST_FROM8);
					9 => wasm.put_uleb32(LIST_FROM9);
					10=> wasm.put_uleb32(LIST_FROM10);
					_ => {
						System.puts(Strings.format1("Translating too long of a list literal: %d\n", elems.length));
						System.error("compile error", "translating too long of a list literal");
					}
				}
			}
		}
	}

	// from BytecodeCompiler
	def addLocal(id: string) -> u32 {
		for (i < locals.length) {
			if (Strings.equal(locals[i], id))
				return u32.view(i);
		}
		def idx = locals.length;
		locals.put(id);
		return u32.view(idx);
	}
}

def ptrAt(o: Object) -> i32 {
	return Pointer.atObject(o) - Pointer.NULL;
}
def ptrAtBox<T>(b: Box<T>) -> i32 {
	return Pointer.atObject(b) - Pointer.NULL;
}
def ptrAtStr(o: string) -> i32 {
	return Pointer.atObject(o) - Pointer.NULL;
}

def funcToFunc(f: ASTData.Func) -> FuncObject {
	// XXX compilation here
	f.body.compile(Arrays.prepend("self", f.params));
	// XXX empty map = no variable capture for a method
	return FuncObjects.newFO(f.id, f.params, [], f.body);
}

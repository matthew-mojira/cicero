/* The runtime is the target of Wasm-level indirections for the GC */

component WasmRuntime {
	/* this are not stacks, since Frame will be responsible for
	 * restoring this state
	 */
	var frame: WasmFrame;
	var strings: Array<string>;
	var funcholes: Array<ASTData.Func>;
	var classholes: Array<ClassObject -> ClassObject>;
	var objects: Vector<Object>;
	var result: int;

	/* assume null object = 0 in objects */

	def isNull(idx: int) -> bool {
		return objects[idx] == null; /* XXX should also be idx == 0 */
	}
	def isTrue(idx: int)  -> bool => objects[idx].isTrue();
	def isFalse(idx: int) -> bool => !objects[idx].isTrue();
	def isFunc(idx: int)  -> bool => objects[idx].instanceOf(ClassObjects.classFunc);
	def isClass(idx: int) -> bool => objects[idx].instanceOf(ClassObjects.classClass);
	def isString(idx: int)-> bool => objects[idx].instanceOf(ClassObjects.classStr);

	def getGlobal(idx: int) -> int {
		def id = strings[idx];
		def obj = frame.getGlobal(id);
		return alloc(obj);
	}

	def getNonlocal(idx: int) -> int {
		def id = strings[idx];
		def obj = frame.getNonlocal(id);
		return alloc(obj);
	}

	def setGlobal(strIdx: int, objIdx: int) -> int {
		def obj = objects[objIdx];
		def id = strings[strIdx];
		frame.setGlobal(id, obj);
		return objIdx;
	}

	def raiseTypeException(actIdx: int, expIdx: int) -> int {
		def act = objects[actIdx];
		def exp = objects[expIdx];
		def msg = Exceptions.typeMismatch(ClassObject.!(exp), act);
		def exn = ExnObjects.fromWasm(msg);
		return alloc(exn);
	}
	def raiseString(strIdx: int) -> int {
		def str = objects[strIdx];
		def exn = ExnObjects.fromWasm(StrObject.!(str).str);
		return alloc(exn);		
	}
	def raiseMissingField(objIdx: int, strIdx: int) -> int {
		def obj = objects[objIdx];
		def str = strings[strIdx];
		def msg = Exceptions.missingField(obj, str);
		def exn = ExnObjects.fromWasm(msg);
		return alloc(exn);
	}

	def pushFrame();
	def popFrame();

	/* Calls to other functions */
	/* TODO make compiler inline these functions */
	def callFunc0(func: FuncObject) => callFuncN(func, []);
	def callFunc1(func: FuncObject, o0: int) => callFuncN(func, [o0]);
	def callFunc2(func: FuncObject, o0: int, o1: int) => callFuncN(func, [o0, o1]);
	def callFunc3(func: FuncObject, o0: int, o1: int, o2: int) => callFuncN(func, [o0, o1, o2]);
	def callFunc4(func: FuncObject, o0: int, o1: int, o2: int, o3: int) => callFuncN(func, [o0, o1, o2, o3]);
	def callFunc5(func: FuncObject, o0: int, o1: int, o2: int, o3: int, o4: int) => callFuncN(func, [o0, o1, o2, o3, o4]);
	def callFunc6(func: FuncObject, o0: int, o1: int, o2: int, o3: int, o4: int, o5: int) => callFuncN(func, [o0, o1, o2, o3, o4, o5]);
	def callFunc7(func: FuncObject, o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int) => callFuncN(func, [o0, o1, o2, o3, o4, o5, o6]);
	def callFunc8(func: FuncObject, o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int, o7: int) => callFuncN(func, [o0, o1, o2, o3, o4, o5, o6, o7]);
	def callFunc9(func: FuncObject, o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int, o7: int, o8: int) => callFuncN(func, [o0, o1, o2, o3, o4, o5, o6, o7, o8]);

	def callFuncN(fv: FuncObject, args: Array<int>) -> bool { /* returns if exception */
		def params = fv.params, code = fv.code;

		// evaluate argument values
		var argv: Array<(string, Object)>;

		if (fv.instanceOf(ClassObjects.classMethod)) {
			argv = Array.new(args.length + 1);
			for (i < args.length) {
				def arg = args[i];
				if (i < params.length) // avoid out of bounds but don't raise exception
					argv[i + 1] = (params[i], objects[arg]);
			}
			argv[0] = ("self", MethodObject.!(fv).obj);
		} else {
			argv = Array.new(args.length);
			for (i < args.length) {
				def arg = args[i];
				if (i < params.length) // avoid out of bounds but don't raise exception
					argv[i] = (params[i], objects[arg]);
			}
		}

		if (args.length != params.length) {
			def obj = ExnObjects.fromWasm(Exceptions.arityMismatch(params.length, args.length));
			result = alloc(obj);
			return true;
		}

		// create new frame (and evaluate)
		def newFrame = frame.newFrame(fv.id, code, argv, fv.nonlocals);
		newFrame.eval();
		match (newFrame.result) {
			OK(v) => {
				result = alloc(v);
				return false;
			}
			Exn(e) => {
				result = alloc(e);
				return true;
			}
			_ => {
				System.error("internal error", "evaluation of frame returned uncomputed");
				return false;
			}
		}
	}

	def getResult() -> int => result;
	def setResult(i: int) -> void => void(result = i);

	def createFunc0(funchole: int) => createFuncN(funchole, []);
	def createFunc1(funchole: int, o0: int) => createFuncN(funchole, [o0]);
	def createFunc2(funchole: int, o0: int, o1: int) => createFuncN(funchole, [o0, o1]);
	def createFunc3(funchole: int, o0: int, o1: int, o2: int) => createFuncN(funchole, [o0, o1, o2]);
	def createFunc4(funchole: int, o0: int, o1: int, o2: int, o3: int) => createFuncN(funchole, [o0, o1, o2, o3]);
	def createFunc5(funchole: int, o0: int, o1: int, o2: int, o3: int, o4: int) => createFuncN(funchole, [o0, o1, o2, o3, o4]);
	def createFunc6(funchole: int, o0: int, o1: int, o2: int, o3: int, o4: int, o5: int) => createFuncN(funchole, [o0, o1, o2, o3, o4, o5]);
	def createFunc7(funchole: int, o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int) => createFuncN(funchole, [o0, o1, o2, o3, o4, o5, o6]);
	def createFunc8(funchole: int, o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int, o7: int) => createFuncN(funchole, [o0, o1, o2, o3, o4, o5, o6, o7]);
	def createFunc9(funchole: int, o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int, o7: int, o8: int) => createFuncN(funchole, [o0, o1, o2, o3, o4, o5, o6, o7, o8]);

	def createFuncN(funcholeIdx: int, nonlocalArgs: Array<int>) -> int {
		def funchole = funcholes[funcholeIdx];
		def nonlocals: Array<(string, Object)> = Array.new(funchole.nonlocals.length);

		var j = 0;
		def fn = FuncObjects.newFO(funchole.id, funchole.params, nonlocals, funchole.body);
		for (i < funchole.nonlocals.length) {
			// if the nonlocal is the function itself (for recursion)
			if (Strings.equal(funchole.nonlocals[i], funchole.id)) {
				nonlocals[i] = (funchole.id, fn);
			} else {
				nonlocals[i] = (funchole.nonlocals[i], objects[nonlocalArgs[j++]]);
			}
		}

		return alloc(fn);
	}

	def getField(objIdx: int, strIdx: int) -> int {
		def obj = objects[objIdx];
		def str = strings[strIdx];
		def field = obj.getField(str);
		return alloc(field);
	}
	def setField(objIdx: int, strIdx: int, valIdx: int) -> int {
		def obj = objects[objIdx];
		def str = strings[strIdx];
		def val = objects[valIdx];
		return if(obj.setField(str, val), valIdx, alloc(null));
	}
	def createClass(superIdx: int, classholeIdx: int) -> bool { /* returns if exception */
		def o = objects[superIdx];
		def classhole = classholes[classholeIdx];

		if (!o.instanceOf(ClassObjects.classClass)) {
			def exn = ExnObjects.fromWasm(Exceptions.typeMismatch(ClassObjects.classClass, o));
			result = alloc(exn);
			return true;
		}

		def superclass = ClassObject.!(o);
		result = alloc(classhole(superclass));
		return false;
	}
	def createObject(clsIdx: int) -> bool { /* returns if exception */
		def clsObj = ClassObject.!(objects[clsIdx]); // already asserted previously
		def parentFr = WasmRuntime.frame;
		def obj = Objects.newObject(clsObj);

		def classes: Vector<ClassObject> = Vector.new();
		for (cls = clsObj; cls != null; cls = cls.superclass)
			classes.put(cls);

		// initialization order is from base class downwards, which
		// may involve reinitializing some fields
		for (cls in classes.reverse().extract()) {
			// initialize fields
			for (field in cls.classFields) {
				def name = field.0, expr = field.1;

				// XXX hackfix
				if (expr == null) continue;
				// create new frames here!
				def frame = parentFr.newFrame(Strings.format2("%s.%s", cls.name, name), expr, [], []);
				frame.eval();
				if (frame.isExn()) {
					result = alloc(frame.getExn());
					return true;
				}
				obj.setField(name, frame.getValue());
			}
			// call initializer
			if (cls.init != null) {
				def args = [("self", obj)];
				def code = cls.init;

				// create new frames here!
				def frame = parentFr.newFrame(Strings.format1("%s.init", cls.name), code, args, []);
				frame.eval();
				if (frame.isExn()) {
					result = alloc(frame.getExn());
					return true;
				}
			} 
		}
		result = alloc(obj);
		return false;
	}

	/* lists */
	def createList0() => ListObjects.fromArray([]);
	def createList1(o0: int) => ListObjects.fromArray(Arrays.map([o0], objects.[]));
	def createList2(o0: int, o1: int) => ListObjects.fromArray(Arrays.map([o0, o1], objects.[]));
	def createList3(o0: int, o1: int, o2: int) => ListObjects.fromArray(Arrays.map([o0, o1, o2], objects.[]));
	def createList4(o0: int, o1: int, o2: int, o3: int) => ListObjects.fromArray(Arrays.map([o0, o1, o2, o3], objects.[]));
	def createList5(o0: int, o1: int, o2: int, o3: int, o4: int) => ListObjects.fromArray(Arrays.map([o0, o1, o2, o3, o4], objects.[]));
	def createList6(o0: int, o1: int, o2: int, o3: int, o4: int, o5: int) => ListObjects.fromArray(Arrays.map([o0, o1, o2, o3, o4, o5], objects.[]));
	def createList7(o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int) => ListObjects.fromArray(Arrays.map([o0, o1, o2, o3, o4, o5, o6], objects.[]));
	def createList8(o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int, o7: int) => ListObjects.fromArray(Arrays.map([o0, o1, o2, o3, o4, o5, o6, o7], objects.[]));
	def createList9(o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int, o7: int, o8: int) => ListObjects.fromArray(Arrays.map([o0, o1, o2, o3, o4, o5, o6, o7, o8], objects.[]));
	def createList10(o0: int, o1: int, o2: int, o3: int, o4: int, o5: int, o6: int, o7: int, o8: int, o9: int) => ListObjects.fromArray(Arrays.map([o0, o1, o2, o3, o4, o5, o6, o7, o8, o9], objects.[]));


	private def alloc(obj: Object) -> int {
		if (obj == null) return 0;

		def idx = objects.length;
		objects.put(obj);
		return idx;
	}
}
